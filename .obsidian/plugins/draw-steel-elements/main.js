/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof require && require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof require && require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DrawSteelAdmonitionPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian28 = require("obsidian");

// src/drawSteelAdmonition/horizontalRuleProcessor.ts
var HorizontalRuleProcessor = class {
  constructor() {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
  }
  postProcess(source, el, ctx) {
    HorizontalRuleProcessor.build(el);
  }
  static build(parent) {
    const container = parent.createEl("div", { cls: "ds-hr-container" });
    container.createEl("div", { cls: "ds-hr-left-line" });
    container.createEl("div", { cls: "ds-hr-center" });
    container.createEl("div", { cls: "ds-hr-right-line" });
  }
};

// src/drawSteelAdmonition/initiativeProcessor.ts
var import_obsidian10 = require("obsidian");

// src/views/StaminaEditModal.ts
var import_obsidian = require("obsidian");
var StaminaEditModal = class extends import_obsidian.Modal {
  constructor(app, staminaBar, isHero, name, updateCallback) {
    super(app);
    // New properties for pending STAMINA and Temp STAMINA changes
    this.pendingStaminaChange = 0;
    this.pendingTempStaminaChange = 0;
    this.staminaBar = staminaBar;
    this.isHero = isHero;
    this.name = name;
    this.updateCallback = updateCallback;
  }
  onOpen() {
    var _a, _b;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `${this.name} Stamina`, cls: "stamina-header" });
    const maxStamina = this.staminaBar.max_stamina;
    const currentStamina = (_a = this.staminaBar.current_stamina) != null ? _a : maxStamina;
    const currentTempStamina = (_b = this.staminaBar.temp_stamina) != null ? _b : 0;
    const negativeStaminaLimit = this.isHero ? Math.ceil(-0.5 * maxStamina) : 0;
    const staminaBarContainer = contentEl.createEl("div", { cls: "stamina-bar-container" });
    if (this.isHero) {
      staminaBarContainer.createEl("div", { cls: "stamina-bar-overlay", text: "Dying" });
    }
    const staminaBar = staminaBarContainer.createEl("div", { cls: "stamina-bar" });
    const staminaBarFillLeft = staminaBar.createEl("div", { cls: "stamina-bar-fill-left" });
    const staminaBarFillRight = staminaBar.createEl("div", { cls: "stamina-bar-fill-right" });
    this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
    const modifierContainer = contentEl.createEl("div", { cls: "modifier-container" });
    const applyContainer = modifierContainer.createEl("div", { cls: "apply-container" });
    const applyRow = applyContainer.createEl("div", { cls: "apply-row" });
    applyRow.createEl("span", { text: "Apply" });
    const applyInput = applyRow.createEl("input", {
      type: "number",
      cls: "apply-input"
    });
    applyInput.value = "0";
    applyInput.focus();
    const damageButton = applyContainer.createEl("button", { cls: "apply-btn" });
    (0, import_obsidian.setIcon)(damageButton.createEl("div", { cls: "btn-icon" }), "sword");
    damageButton.createEl("div", { cls: "btn-text", text: "Damage" });
    damageButton.addEventListener("click", () => {
      const adjustment = parseInt(applyInput.value);
      if (!isNaN(adjustment)) {
        let tempStaminaAvailable = currentTempStamina + this.pendingTempStaminaChange;
        let tempStaminaUsed = Math.min(adjustment, tempStaminaAvailable);
        this.pendingTempStaminaChange -= tempStaminaUsed;
        let remainingDamage = adjustment - tempStaminaUsed;
        this.pendingStaminaChange -= Math.min(remainingDamage, this.amountToDeath(currentStamina, negativeStaminaLimit));
        this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
        tempStaminaInput.value = (currentTempStamina + this.pendingTempStaminaChange).toString();
        this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
        this.updateActionButton(actionButton);
      }
    });
    const healingButton = applyContainer.createEl("button", { cls: "apply-btn" });
    (0, import_obsidian.setIcon)(healingButton.createEl("div", { cls: "btn-icon" }), "plus");
    healingButton.createEl("div", { cls: "btn-text", text: "Healing" });
    healingButton.addEventListener("click", () => {
      const adjustment = parseInt(applyInput.value);
      if (!isNaN(adjustment)) {
        this.pendingStaminaChange += Math.min(adjustment, this.amountToMaxStamina(currentStamina, maxStamina));
        this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
        this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
        this.updateActionButton(actionButton);
      }
    });
    modifierContainer.createEl("div", { cls: "vertical-divider", text: " " });
    const staminaModContainer = modifierContainer.createEl("div", { cls: "stamina-mod-container" });
    const staminaNumericContainer = staminaModContainer.createEl("div", { cls: "stamina-numeric-container" });
    const decrementButton = staminaNumericContainer.createEl("div", { cls: "stamina-adjust-btn" });
    (0, import_obsidian.setIcon)(decrementButton, "minus-circle");
    decrementButton.addEventListener("click", () => {
      this.pendingStaminaChange -= Math.min(1, this.amountToDeath(currentStamina, negativeStaminaLimit));
      this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
      this.updateActionButton(actionButton);
    });
    const staminaValueDisplay = staminaNumericContainer.createEl("input", {
      type: "number",
      cls: "stamina-value-display"
    });
    staminaValueDisplay.value = (currentStamina + this.pendingStaminaChange).toString();
    staminaValueDisplay.autofocus = false;
    staminaValueDisplay.addEventListener("input", () => {
      const newStaminaValue = parseInt(staminaValueDisplay.value);
      if (!isNaN(newStaminaValue)) {
        this.pendingStaminaChange = newStaminaValue - currentStamina;
        this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
        this.updateActionButton(actionButton);
      }
    });
    staminaNumericContainer.createEl("span", { text: `/ ${maxStamina}`, cls: "max-stamina-display" });
    const incrementButton = staminaNumericContainer.createEl("div", { cls: "stamina-adjust-btn" });
    (0, import_obsidian.setIcon)(incrementButton, "plus-circle");
    incrementButton.addEventListener("click", () => {
      this.pendingStaminaChange += Math.min(1, this.amountToMaxStamina(currentStamina, maxStamina));
      this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
      this.updateActionButton(actionButton);
    });
    const tempStaminaContainer = staminaModContainer.createEl("div", { cls: "temp-stamina-container" });
    tempStaminaContainer.createEl("div", { cls: "temp-stamina-title", text: "Temporary Stamina" });
    const tempStaminaBody = tempStaminaContainer.createEl("div", { cls: "temp-stamina-body" });
    const decrementTempButton = tempStaminaBody.createEl("div", { cls: "temp-stamina-btn" });
    (0, import_obsidian.setIcon)(decrementTempButton, "minus-circle");
    decrementTempButton.addEventListener("click", () => {
      if (currentTempStamina + this.pendingTempStaminaChange <= 0) {
        return;
      }
      this.pendingTempStaminaChange -= 1;
      tempStaminaInput.value = (currentTempStamina + this.pendingTempStaminaChange).toString();
      this.updateActionButton(actionButton);
    });
    const tempStaminaInput = tempStaminaBody.createEl("input", {
      type: "number",
      cls: "temp-stamina-input"
    });
    tempStaminaInput.min = "0";
    tempStaminaInput.value = (currentTempStamina + this.pendingTempStaminaChange).toString();
    tempStaminaInput.addEventListener("input", () => {
      let newTempStaminaValue = parseInt(tempStaminaInput.value);
      if (!isNaN(newTempStaminaValue)) {
        if (newTempStaminaValue < 0) {
          newTempStaminaValue = 0;
          tempStaminaInput.value = "0";
        }
        this.pendingTempStaminaChange = newTempStaminaValue - currentTempStamina;
        this.updateActionButton(actionButton);
      }
    });
    const incrementTempButton = tempStaminaBody.createEl("div", { cls: "temp-stamina-btn" });
    (0, import_obsidian.setIcon)(incrementTempButton, "plus-circle");
    incrementTempButton.addEventListener("click", () => {
      this.pendingTempStaminaChange += 1;
      tempStaminaInput.value = (currentTempStamina + this.pendingTempStaminaChange).toString();
      this.updateActionButton(actionButton);
    });
    modifierContainer.createEl("div", { cls: "vertical-divider", text: " " });
    const quickModContainer = modifierContainer.createEl("div", { cls: "quick-mod-container" });
    const killButton = quickModContainer.createEl("button", { cls: "quick-mod-btn" });
    (0, import_obsidian.setIcon)(killButton.createEl("div", { cls: "btn-icon" }), "skull");
    killButton.createEl("div", { cls: "btn-text", text: "Kill" });
    killButton.addEventListener("click", () => {
      this.pendingStaminaChange = negativeStaminaLimit - currentStamina;
      this.pendingTempStaminaChange = -currentTempStamina;
      tempStaminaInput.value = "0";
      this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
      this.updateActionButton(actionButton);
    });
    const fullHealButton = quickModContainer.createEl("button", { cls: "quick-mod-btn" });
    (0, import_obsidian.setIcon)(fullHealButton.createEl("div", { cls: "btn-icon" }), "plus");
    fullHealButton.createEl("div", { cls: "btn-text", text: "Full Heal" });
    fullHealButton.addEventListener("click", () => {
      this.pendingStaminaChange = maxStamina - currentStamina;
      this.pendingTempStaminaChange = -currentTempStamina;
      tempStaminaInput.value = "0";
      this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
      this.updateActionButton(actionButton);
    });
    const recoveryButton = quickModContainer.createEl("button", { cls: "quick-mod-btn" });
    (0, import_obsidian.setIcon)(recoveryButton.createEl("div", { cls: "btn-icon" }), "syringe");
    recoveryButton.createEl("div", { cls: "btn-text", text: "Spend Recovery" });
    recoveryButton.addEventListener("click", () => {
      const adjustment = Math.min(Math.floor(maxStamina / 3), maxStamina);
      if (!isNaN(adjustment)) {
        this.pendingStaminaChange += adjustment;
        this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
        this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
        this.updateActionButton(actionButton);
      }
    });
    const actionButtonContainer = contentEl.createEl("div", { cls: "action-button-container" });
    const resetButton = actionButtonContainer.createEl("button", { cls: "reset-button" });
    (0, import_obsidian.setIcon)(resetButton.createEl("div", { cls: "btn-icon" }), "undo");
    resetButton.createEl("div", { cls: "btn-text", text: "Reset" });
    resetButton.addEventListener("click", () => {
      this.pendingStaminaChange = 0;
      this.pendingTempStaminaChange = 0;
      this.updateStaminaDisplay(staminaValueDisplay, currentStamina);
      tempStaminaInput.value = (currentTempStamina + this.pendingTempStaminaChange).toString();
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina);
      this.updateActionButton(actionButton);
    });
    const actionButton = actionButtonContainer.createEl("button", { cls: "action-button" });
    this.updateActionButton(actionButton);
    actionButton.addEventListener("click", () => {
      const newCurrentStamina = this.clampStamina(currentStamina + this.pendingStaminaChange, negativeStaminaLimit, maxStamina);
      this.staminaBar.current_stamina = newCurrentStamina;
      const newTempStamina = currentTempStamina + this.pendingTempStaminaChange;
      this.staminaBar.temp_stamina = newTempStamina;
      this.updateCallback();
      this.close();
    });
    queueMicrotask(() => {
      applyInput.focus();
    });
  }
  clampStamina(stamina, negativeStaminaLimit, maxPossibleStamina) {
    stamina = Math.min(stamina, maxPossibleStamina);
    stamina = Math.max(stamina, negativeStaminaLimit);
    return stamina;
  }
  amountToMaxStamina(currentStamina, maxStamina) {
    return maxStamina - currentStamina - this.pendingStaminaChange;
  }
  amountToDeath(currentStamina, negativeStaminaLimit) {
    return negativeStaminaLimit * -1 + currentStamina + this.pendingStaminaChange;
  }
  updateStaminaBar(staminaBarFillLeft, staminaBarFillRight, negativeStaminaLimit, maxStamina) {
    const dyingLength = negativeStaminaLimit * -1;
    const barLength = maxStamina + dyingLength;
    const adjustedCurrentStamina = this.staminaBar.current_stamina + dyingLength;
    if (this.pendingStaminaChange > 0) {
      staminaBarFillLeft.style.width = `${adjustedCurrentStamina / barLength * 100}%`;
      staminaBarFillLeft.style.backgroundColor = "limegreen";
      staminaBarFillRight.style.width = `${this.pendingStaminaChange / barLength * 100}%`;
      staminaBarFillRight.style.backgroundColor = "deepskyblue";
      staminaBarFillRight.style.borderRadius = "0 3px 3px 0";
    } else if (this.pendingStaminaChange < 0) {
      staminaBarFillLeft.style.width = `${(adjustedCurrentStamina + this.pendingStaminaChange) / barLength * 100}%`;
      staminaBarFillLeft.style.backgroundColor = "limegreen";
      staminaBarFillRight.style.width = `${this.pendingStaminaChange / barLength * -100}%`;
      staminaBarFillRight.style.backgroundColor = "crimson";
      staminaBarFillRight.style.borderRadius = "3px 0 0 3px";
    } else {
      staminaBarFillLeft.style.width = `${adjustedCurrentStamina / barLength * 100}%`;
      staminaBarFillLeft.style.backgroundColor = "limegreen";
      staminaBarFillRight.style.width = `0%`;
      staminaBarFillRight.style.backgroundColor = "deepskyblue";
    }
  }
  updateStaminaDisplay(staminaValueDisplay, currentStamina) {
    const newStaminaValue = currentStamina + this.pendingStaminaChange;
    staminaValueDisplay.value = newStaminaValue.toString();
  }
  updateActionButton(actionButton) {
    const staminaChange = this.pendingStaminaChange;
    const tempStaminaChange = this.pendingTempStaminaChange;
    let actionText = "";
    if (staminaChange < 0) {
      actionText += `Lose ${Math.abs(staminaChange)} Stamina`;
    } else if (staminaChange > 0) {
      actionText += `Gain ${staminaChange} Stamina`;
    }
    if (tempStaminaChange !== 0) {
      if (actionText !== "") {
        actionText += " and ";
      }
      if (tempStaminaChange > 0) {
        actionText += `Gain ${tempStaminaChange} Temp Stamina`;
      } else {
        actionText += `Lose ${Math.abs(tempStaminaChange)} Temp Stamina`;
      }
    }
    if (actionText === "") {
      actionText = "No Stamina Change";
    }
    actionButton.textContent = actionText;
    actionButton.toggleClass("disabled", staminaChange === 0 && tempStaminaChange === 0);
  }
};

// src/utils/Conditions.ts
var ConditionManager = class {
  constructor() {
    this.conditions = [
      { key: "bleeding", displayName: "Bleeding", iconName: "droplet" },
      { key: "dazed", displayName: "Dazed", iconName: "waves" },
      { key: "frightened", displayName: "Frightened", iconName: "ghost" },
      { key: "grabbed", displayName: "Grabbed", iconName: "hand" },
      { key: "prone", displayName: "Prone", iconName: "bed" },
      { key: "restrained", displayName: "Restrained", iconName: "navigation-off" },
      { key: "slowed", displayName: "Slowed", iconName: "snail" },
      { key: "weakened", displayName: "Weakened", iconName: "trending-down" }
    ];
    this.pseudoConditions = [
      { key: "marked", displayName: "Marked", iconName: "locate-fixed" },
      { key: "used-triggered-action", displayName: "Triggered Action Used", iconName: "repeat" },
      { key: "covered", displayName: "Covered", iconName: "trees" },
      { key: "concealed", displayName: "Concealed", iconName: "cloud-fog" },
      { key: "dead", displayName: "Dead", iconName: "skull" },
      { key: "defending", displayName: "Defending", iconName: "shield" },
      { key: "dying", displayName: "Dying", iconName: "heart-crack" },
      { key: "falling", displayName: "Falling", iconName: "arrow-big-down-dash" },
      { key: "flanking", displayName: "Flanking", iconName: "minimize-2" },
      { key: "hidden", displayName: "Hidden", iconName: "locate-off" },
      { key: "high-ground", displayName: "High Ground", iconName: "layers" },
      { key: "invisible", displayName: "Invisible", iconName: "eye-off" },
      { key: "sneaking", displayName: "Sneaking", iconName: "more-horizontal" },
      { key: "unconscious", displayName: "Unconscious", iconName: "zap-off" },
      { key: "winded", displayName: "Winded", iconName: "wind" },
      { key: "taunted", displayName: "Taunted", iconName: "mouse-pointer-click" }
    ];
  }
  getAnyConditionByKey(key) {
    return this.getConditionByKey(key) || this.getPseudoConditionByKey(key);
  }
  getConditions() {
    return this.conditions;
  }
  getConditionByKey(key) {
    return this.conditions.find((c) => c.key === key);
  }
  getPseudoConditions() {
    return this.pseudoConditions;
  }
  getPseudoConditionByKey(key) {
    return this.pseudoConditions.find((c) => c.key === key);
  }
};

// src/views/ConditionSelectModal.ts
var import_obsidian3 = require("obsidian");

// src/views/CustomizeConditionModal.ts
var import_obsidian2 = require("obsidian");
var CustomizeConditionModal = class extends import_obsidian2.Modal {
  constructor(app, conditionData, conditionConfig, onUpdate) {
    super(app);
    this.conditionData = { ...conditionData };
    this.conditionConfig = conditionConfig;
    this.onUpdate = onUpdate;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const modalContainer = contentEl.createEl("div", { cls: "customize-condition-modal" });
    modalContainer.createEl("h2", { text: "Customize Condition" });
    const bodyContainer = modalContainer.createEl("div", { cls: "customize-condition-body" });
    const toolsContainer = bodyContainer.createEl("div", { cls: "customize-condition-tools" });
    const colorPickerContainer = toolsContainer.createEl("div", { cls: "color-picker-container" });
    colorPickerContainer.createEl("label", { text: "Color: " });
    const colorInput = colorPickerContainer.createEl("input", { type: "color" });
    colorInput.value = this.conditionData.color || "#ffffff";
    const effectContainer = toolsContainer.createEl("div", { cls: "effect-container" });
    effectContainer.createEl("label", { text: "Effect: " });
    const effectSelect = effectContainer.createEl("select");
    const effects = ["static", "blink", "glow", "glow-pulse", "breathing", "blur-pulse"];
    effects.forEach((effect) => {
      const option = effectSelect.createEl("option", { text: effect, value: effect });
      if (this.conditionData.effect === effect)
        option.selected = true;
    });
    const previewContainer = bodyContainer.createEl("div", { cls: "customize-condition-preview", text: "asdf" });
    (0, import_obsidian2.setIcon)(previewContainer, this.conditionConfig.iconName);
    effectSelect.addEventListener("change", () => {
      this.conditionData.effect = effectSelect.value;
      this.updateIconPreview(previewContainer, this.conditionData);
    });
    colorInput.addEventListener("change", () => {
      this.conditionData.color = colorInput.value;
      this.updateIconPreview(previewContainer, this.conditionData);
    });
    const buttonsContainer = modalContainer.createEl("div", { cls: "modal-buttons" });
    const cancelButton = buttonsContainer.createEl("button", { text: "Cancel" });
    const saveButton = buttonsContainer.createEl("button", { text: "Save" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    saveButton.addEventListener("click", () => {
      this.conditionData.color = colorInput.value;
      this.conditionData.effect = effectSelect.value;
      this.onUpdate(this.conditionData);
      this.close();
    });
  }
  // TODO - this is duplicated code
  updateIconPreview(iconEl, conditionData) {
    if (conditionData.color) {
      iconEl.style.color = conditionData.color;
    } else {
      iconEl.style.color = "";
    }
    iconEl.classList.remove(
      "condition-effect-blink",
      "condition-effect-glow",
      "condition-effect-glow-pulse",
      "condition-effect-glow-pulse",
      "condition-effect-breathing",
      "condition-effect-blur-pulse"
    );
    if (conditionData.effect && conditionData.effect !== "static") {
      iconEl.classList.add(`condition-effect-${conditionData.effect}`);
    }
  }
};

// src/views/ConditionSelectModal.ts
var AddConditionsModal = class extends import_obsidian3.Modal {
  constructor(app, character, conditionManager, onAdd) {
    super(app);
    this.character = character;
    this.conditionManager = conditionManager;
    this.onAdd = onAdd;
    this.selectedConditions = /* @__PURE__ */ new Map();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const modalContainer = contentEl.createEl("div", { cls: "add-condition-modal" });
    modalContainer.createEl("h2", { text: "Add Conditions" });
    const conditionsList = modalContainer.createEl("div", { cls: "conditions-list" });
    this.conditionManager.getConditions().forEach((condition) => {
      this.addConditionToModal(conditionsList, condition);
    });
    const divider = conditionsList.createEl("div", { cls: "horizontal-divider" });
    this.conditionManager.getPseudoConditions().forEach((condition) => {
      this.addConditionToModal(conditionsList, condition);
    });
    const buttonsContainer = modalContainer.createEl("div", { cls: "modal-buttons" });
    const cancelButton = buttonsContainer.createEl("button", { text: "Cancel" });
    const addButton = buttonsContainer.createEl("button", { text: "Add Conditions" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    addButton.addEventListener("click", () => {
      this.onAdd(Array.from(this.selectedConditions.values()));
      this.close();
    });
  }
  addConditionToModal(conditionsList, condition) {
    const conditionEl = conditionsList.createEl("div", { cls: "condition-item" });
    const iconEl = conditionEl.createEl("div", { cls: "condition-icon-preview" });
    (0, import_obsidian3.setIcon)(iconEl, condition.iconName);
    const label = conditionEl.createEl("div", { cls: "condition-label", text: condition.displayName });
    const customizeIconEl = conditionEl.createEl("div", { cls: "condition-customize-icon" });
    (0, import_obsidian3.setIcon)(customizeIconEl, "cog");
    customizeIconEl.title = "Customize Condition";
    customizeIconEl.style.display = "none";
    conditionEl.addEventListener("mouseenter", () => {
      customizeIconEl.style.display = "";
    });
    conditionEl.addEventListener("mouseleave", () => {
      customizeIconEl.style.display = "none";
    });
    customizeIconEl.addEventListener("click", (event) => {
      event.stopPropagation();
      this.openCustomizeConditionModal(condition.key, iconEl, condition);
    });
    conditionEl.addEventListener("click", () => {
      if (this.selectedConditions.has(condition.key)) {
        this.selectedConditions.delete(condition.key);
        conditionEl.classList.remove("selected");
      } else {
        const conditionData = { key: condition.key };
        this.selectedConditions.set(condition.key, conditionData);
        conditionEl.classList.add("selected");
      }
    });
    conditionEl.addEventListener("dblclick", (event) => {
      event.stopPropagation();
      this.openCustomizeConditionModal(condition.key, iconEl, condition);
    });
    conditionEl.appendChild(iconEl);
    conditionEl.appendChild(label);
    conditionEl.appendChild(customizeIconEl);
  }
  // Updates the icon preview with customizations
  updateIconPreview(iconEl, conditionConfig, conditionData) {
    iconEl.className = "condition-icon-preview";
    (0, import_obsidian3.setIcon)(iconEl, conditionConfig.iconName);
    if (conditionData.color) {
      iconEl.style.color = conditionData.color;
    } else {
      iconEl.style.color = "";
    }
    iconEl.classList.remove(
      "condition-effect-blink",
      "condition-effect-glow",
      "condition-effect-glow-pulse",
      "condition-effect-breathing",
      "condition-effect-blur-pulse"
    );
    if (conditionData.effect && conditionData.effect !== "static") {
      iconEl.classList.add(`condition-effect-${conditionData.effect}`);
    }
  }
  // Opens the customize condition modal and updates the icon preview upon changes
  openCustomizeConditionModal(conditionKey, iconEl, conditionConfig) {
    let conditionData = this.selectedConditions.get(conditionKey);
    if (!conditionData) {
      conditionData = { key: conditionKey };
      this.selectedConditions.set(conditionKey, conditionData);
      const conditionEl = iconEl.parentElement;
      if (conditionEl) {
        conditionEl.classList.add("selected");
      }
    }
    const customizeModal = new CustomizeConditionModal(
      this.app,
      conditionData,
      conditionConfig,
      (updatedCondition) => {
        this.selectedConditions.set(conditionKey, updatedCondition);
        this.updateIconPreview(iconEl, conditionConfig, updatedCondition);
      }
    );
    customizeModal.open();
  }
};

// src/utils/Images.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_IMAGE_PATH = "Media/token_1.png";
var Images = class {
  static async resolveImageSource(app, imgSrcRaw) {
    const obsidianLinkMatch = imgSrcRaw.match(/!\[\[(.+?)\]\]/);
    if (obsidianLinkMatch) {
      const fileName = obsidianLinkMatch[1];
      const file2 = app.metadataCache.getFirstLinkpathDest(fileName, "");
      if (file2 instanceof import_obsidian4.TFile) {
        return app.vault.getResourcePath(file2);
      } else {
        throw new Error("Image file not found in vault.");
      }
    }
    if (imgSrcRaw.match(/^https?:\/\//)) {
      return imgSrcRaw;
    }
    const file = app.vault.getAbstractFileByPath(imgSrcRaw);
    if (file instanceof import_obsidian4.TFile) {
      return app.vault.getResourcePath(file);
    } else {
      throw new Error("Image file not found in vault.");
    }
  }
};

// src/utils/CodeBlocks.ts
var import_obsidian5 = require("obsidian");
var CodeBlocks = class {
  static async updateInitiativeTracker(app, data, ctx) {
    return CodeBlocks.updateCodeBlock(app, data, ctx, "ds-initiative");
  }
  static async updateNegotiationTracker(app, data, ctx) {
    return CodeBlocks.updateCodeBlock(app, data, ctx, "ds-negotiation-tracker");
  }
  static async updateStatblock(app, data, ctx) {
    return CodeBlocks.updateCodeBlock(app, data, ctx, "ds-statblock");
  }
  static async updateStaminaBar(app, data, ctx) {
    return CodeBlocks.updateCodeBlock(app, data, ctx, "ds-stamina");
  }
  static async updateCounter(app, data, ctx) {
    return CodeBlocks.updateCodeBlock(app, data, ctx, "ds-counter");
  }
  // TODO - can extract language out from ctx
  static async updateCodeBlock(app, data, ctx, language) {
    let file = null;
    if (ctx.sourcePath) {
      file = app.vault.getAbstractFileByPath(ctx.sourcePath);
      if (!file || !(file instanceof import_obsidian5.TFile)) {
        console.warn("Unable to find the file to update.");
        return;
      }
      await this.updateMarkdownCodeBlock(app, file, data, ctx, language);
    } else {
      await this.findCanvasNodeAndUpdate(app, ctx, data, language);
    }
  }
  static async findCanvasNodeAndUpdate(app, ctx, data, language) {
    const canvasView = app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
    if ((canvasView == null ? void 0 : canvasView.getViewType()) !== "canvas") {
      console.log("Failed to find canvas associated with markdown context.  Change NOT saved.");
      return;
    }
    const canvas = canvasView.canvas;
    const selection = Array.from(canvas.selection);
    for (let selectionKey in selection) {
      if (selection[selectionKey].text === ctx.getSectionInfo(ctx.el).text) {
        await this.updateCanvasCard(app, canvas, selection[selectionKey], data, language);
        return;
      }
    }
    console.log("Failed to find canvas associated with markdown context.  Change NOT saved.");
    return;
  }
  static async updateCanvasCard(app, canvas, node, data, language) {
    const newCodeBlockContent = [];
    newCodeBlockContent.push("```" + language);
    newCodeBlockContent.push((0, import_obsidian5.stringifyYaml)(data).trim());
    newCodeBlockContent.push("```");
    node.setData({
      ...node.getData(),
      text: newCodeBlockContent.join("\n")
    });
    canvas.getData();
    canvas.view.requestSave();
    return;
  }
  static async updateMarkdownCodeBlock(app, file, data, ctx, language) {
    const content = await app.vault.read(file);
    const lines = content.split("\n");
    const section = ctx.getSectionInfo(ctx.el);
    if (!section)
      return;
    const { lineStart, lineEnd } = section;
    const newCodeBlockContent = [];
    newCodeBlockContent.push("```" + language);
    newCodeBlockContent.push((0, import_obsidian5.stringifyYaml)(data).trim());
    newCodeBlockContent.push("```");
    lines.splice(lineStart, lineEnd - lineStart + 1, ...newCodeBlockContent);
    const newContent = lines.join("\n");
    await app.vault.modify(file, newContent);
  }
};

// src/drawSteelAdmonition/EncounterData.ts
var import_obsidian6 = require("obsidian");
function resetEncounter(data) {
  data.heroes.forEach((hero) => {
    hero.current_stamina = void 0;
    hero.temp_stamina = void 0;
    hero.has_taken_turn = void 0;
    hero.conditions = void 0;
  });
  data.enemy_groups.forEach((group) => {
    group.has_taken_turn = void 0;
    group.selectedInstanceKey = void 0;
    if (group.is_squad) {
      group.minion_stamina_pool = void 0;
    }
    group.creatures.forEach((creatureType) => {
      creatureType.instances = void 0;
    });
  });
  data.malice.value = 0;
}
function parseEncounterData(source) {
  var _a, _b;
  let data;
  try {
    data = (0, import_obsidian6.parseYaml)(source);
  } catch (error) {
    throw new Error("Invalid YAML format: " + error.message);
  }
  if (typeof data !== "object" || data === null) {
    throw new Error("The input must be a YAML object.");
  }
  if (!data.heroes || !Array.isArray(data.heroes)) {
    throw new Error("Invalid data: 'heroes' field is missing or is not a list.");
  }
  if (!data.enemy_groups || !Array.isArray(data.enemy_groups)) {
    throw new Error("Invalid data: 'enemy_groups' field is missing or is not a list.");
  }
  data.heroes.forEach((hero, index) => {
    var _a2, _b2, _c, _d, _e;
    if (!hero.name) {
      throw new Error(`Hero at index ${index} is missing the 'name' field.`);
    }
    if (typeof hero.max_stamina !== "number") {
      throw new Error(`Hero '${hero.name}' is missing or has an invalid 'max_stamina' field.`);
    }
    hero.conditions = (_b2 = (_a2 = hero.conditions) == null ? void 0 : _a2.map((cond) => {
      var _a3, _b3;
      if (typeof cond === "string") {
        return cond;
      } else if (typeof cond === "object" && cond.key) {
        return {
          key: cond.key,
          color: (_a3 = cond.color) != null ? _a3 : null,
          effect: (_b3 = cond.effect) != null ? _b3 : null
        };
      } else {
        throw new Error(`Invalid condition format for hero '${hero.name}'.`);
      }
    })) != null ? _b2 : [];
    hero.isHero = true;
    hero.has_taken_turn = (_c = hero.has_taken_turn) != null ? _c : false;
    hero.current_stamina = (_d = hero.current_stamina) != null ? _d : hero.max_stamina;
    hero.temp_stamina = (_e = hero.temp_stamina) != null ? _e : 0;
  });
  data.enemy_groups.forEach((group, groupIndex) => {
    var _a2, _b2;
    if (!group.name) {
      throw new Error(`Enemy group at index ${groupIndex} is missing the 'name' field.`);
    }
    if (!group.creatures || !Array.isArray(group.creatures)) {
      throw new Error(`Enemy group '${group.name}' has an invalid or missing 'creatures' field.`);
    }
    group.has_taken_turn = (_a2 = group.has_taken_turn) != null ? _a2 : false;
    group.is_squad = (_b2 = group.is_squad) != null ? _b2 : false;
    if (group.is_squad) {
      if (group.creatures.length > 2) {
        throw new Error(
          `Squad '${group.name}' can have at most two creatures (minions and an optional captain).`
        );
      }
      let minionCount = 0;
      let captainCount = 0;
      group.creatures.forEach((creature) => {
        if (!creature.squad_role) {
          throw new Error(
            `Creature '${creature.name}' in squad '${group.name}' must have a 'squad_role' of 'minion' or 'captain'.`
          );
        }
        if (creature.squad_role === "minion") {
          minionCount += 1;
        } else if (creature.squad_role === "captain") {
          captainCount += 1;
        } else {
          throw new Error(
            `Creature '${creature.name}' in squad '${group.name}' has an invalid 'squad_role' value.`
          );
        }
      });
      if (minionCount === 0) {
        throw new Error(`Squad '${group.name}' must have at least one minion creature.`);
      }
      if (minionCount > 1) {
        throw new Error(`Squad '${group.name}' can have only one minion creature type.`);
      }
      if (captainCount > 1) {
        throw new Error(`Squad '${group.name}' can have at most one captain creature.`);
      }
    }
    group.creatures.forEach((creature, creatureIndex) => {
      if (!creature.name) {
        throw new Error(
          `Creature at index ${creatureIndex} in group '${group.name}' is missing the 'name' field.`
        );
      }
      if (typeof creature.amount !== "number") {
        throw new Error(
          `Creature '${creature.name}' in group '${group.name}' is missing or has an invalid 'amount' field.`
        );
      }
      if (typeof creature.max_stamina !== "number") {
        throw new Error(
          `Creature '${creature.name}' in group '${group.name}' is missing or has an invalid 'max_stamina' field.`
        );
      }
      creature.isHero = false;
      if (group.is_squad && creature.squad_role === "minion") {
        if (group.minion_stamina_pool == null) {
          group.minion_stamina_pool = creature.max_stamina * creature.amount;
        }
        if (!creature.instances || creature.instances.length !== creature.amount) {
          creature.instances = [];
          for (let i = 0; i < creature.amount; i++) {
            creature.instances.push({
              id: i + 1,
              conditions: []
              // current_stamina and temp_stamina are not used for minions in squads
            });
          }
        } else {
          creature.instances.forEach((instance, instanceIndex) => {
            var _a3, _b3;
            if (typeof instance.id !== "number") {
              throw new Error(
                `Instance at index ${instanceIndex} of creature '${creature.name}' in group '${group.name}' is missing or has an invalid 'id' field.`
              );
            }
            instance.conditions = (_b3 = (_a3 = instance.conditions) == null ? void 0 : _a3.map((cond) => {
              var _a4, _b4;
              if (typeof cond === "string") {
                return cond;
              } else if (typeof cond === "object" && cond.key) {
                return {
                  key: cond.key,
                  color: (_a4 = cond.color) != null ? _a4 : null,
                  effect: (_b4 = cond.effect) != null ? _b4 : null
                };
              } else {
                throw new Error(
                  `Invalid condition format for instance '${instance.id}' of creature '${creature.name}'.`
                );
              }
            })) != null ? _b3 : [];
          });
        }
      } else {
        if (!creature.instances || creature.instances.length !== creature.amount) {
          creature.instances = [];
          for (let i = 0; i < creature.amount; i++) {
            creature.instances.push({
              id: i + 1,
              current_stamina: creature.max_stamina,
              temp_stamina: 0,
              conditions: []
            });
          }
        } else {
          creature.instances.forEach((instance, instanceIndex) => {
            var _a3, _b3, _c, _d;
            if (typeof instance.id !== "number") {
              throw new Error(
                `Instance at index ${instanceIndex} of creature '${creature.name}' in group '${group.name}' is missing or has an invalid 'id' field.`
              );
            }
            instance.current_stamina = (_a3 = instance.current_stamina) != null ? _a3 : creature.max_stamina;
            instance.temp_stamina = (_b3 = instance.temp_stamina) != null ? _b3 : 0;
            instance.conditions = (_d = (_c = instance.conditions) == null ? void 0 : _c.map((cond) => {
              var _a4, _b4;
              if (typeof cond === "string") {
                return cond;
              } else if (typeof cond === "object" && cond.key) {
                return {
                  key: cond.key,
                  color: (_a4 = cond.color) != null ? _a4 : null,
                  effect: (_b4 = cond.effect) != null ? _b4 : null
                };
              } else {
                throw new Error(
                  `Invalid condition format for instance '${instance.id}' of creature '${creature.name}'.`
                );
              }
            })) != null ? _d : [];
          });
        }
      }
    });
  });
  data.malice = (_b = data.malice) != null ? _b : (_a = data.villain_power) != null ? _a : { value: 0 };
  if (typeof data.malice.value !== "number") {
    throw new Error("Invalid data: 'malice.value' must be a number.");
  }
  return data;
}

// src/views/ResetEncounterModal.ts
var import_obsidian7 = require("obsidian");
var ResetEncounterModal = class extends import_obsidian7.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Confirm Encounter Reset" });
    contentEl.createEl("p", { text: "Are you sure you want to reset the encounter data?  All state will be lost including current stamina, conditions, turn tracker, and villain power." });
    const buttonContainer = contentEl.createEl("div", { cls: "modal-button-container" });
    const confirmButton = buttonContainer.createEl("button", { text: "Yes, Reset", cls: "mod-warning" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    confirmButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/MinionStaminaPoolModal.ts
var import_obsidian8 = require("obsidian");
var MinionStaminaPoolModal = class extends import_obsidian8.Modal {
  constructor(app, group, creature, data, ctx, updateCallback) {
    super(app);
    // New properties for pending STAMINA changes
    this.pendingStaminaChange = 0;
    this.minionCheckboxes = [];
    this.group = group;
    this.creature = creature;
    this.data = data;
    this.ctx = ctx;
    this.updateCallback = updateCallback;
  }
  onOpen() {
    var _a, _b;
    const { contentEl } = this;
    contentEl.empty();
    const minionsStaminaModal = contentEl.createEl("div", { cls: "minion-stamina-modal" });
    minionsStaminaModal.createEl("h2", { text: `${this.group.name} - Minion Stamina Pool`, cls: "stamina-header" });
    const minionMaxStamina = this.creature.max_stamina;
    const aliveMinions = this.creature.instances.filter((inst) => !inst.isDead).length;
    const poolMaxStamina = aliveMinions * minionMaxStamina;
    const poolCurrentStamina = (_a = this.group.minion_stamina_pool) != null ? _a : poolMaxStamina;
    const staminaBarContainer = minionsStaminaModal.createEl("div", { cls: "stamina-bar-container" });
    const staminaBar = staminaBarContainer.createEl("div", { cls: "stamina-bar" });
    const staminaBarFillLeft = staminaBar.createEl("div", { cls: "stamina-bar-fill stamina-bar-fill-left" });
    const staminaBarFillRight = staminaBar.createEl("div", { cls: "stamina-bar-fill stamina-bar-fill-right" });
    for (let i = 1; i < aliveMinions; i++) {
      const tickPosition = i * minionMaxStamina / poolMaxStamina;
      const tick = staminaBar.createEl("div", { cls: "stamina-bar-tick" });
      tick.style.left = `${tickPosition * 100}%`;
    }
    this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
    const staminaModContainer = minionsStaminaModal.createEl("div", { cls: "stamina-mod-container" });
    const decrementButton = staminaModContainer.createEl("div", { cls: "stamina-adjust-btn" });
    (0, import_obsidian8.setIcon)(decrementButton, "minus-circle");
    decrementButton.addEventListener("click", () => {
      this.pendingStaminaChange -= Math.min(1, poolCurrentStamina + this.pendingStaminaChange);
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
      this.updateInfoText(infoText);
      this.updateCheckboxes();
      this.updateActionButton(actionButton, warningIcon);
    });
    const staminaValueDisplay = staminaModContainer.createEl("input", {
      type: "number",
      cls: "stamina-value-display"
    });
    staminaValueDisplay.value = (poolCurrentStamina + this.pendingStaminaChange).toString();
    staminaValueDisplay.addEventListener("input", () => {
      const newStaminaValue = parseInt(staminaValueDisplay.value);
      if (!isNaN(newStaminaValue)) {
        this.pendingStaminaChange = newStaminaValue - poolCurrentStamina;
        this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
        this.updateInfoText(infoText);
        this.updateCheckboxes();
        this.updateActionButton(actionButton, warningIcon);
      }
    });
    staminaModContainer.createEl("span", {
      text: `/ ${poolMaxStamina}`,
      cls: "max-stamina-display"
    });
    const incrementButton = staminaModContainer.createEl("div", { cls: "stamina-adjust-btn" });
    (0, import_obsidian8.setIcon)(incrementButton, "plus-circle");
    incrementButton.addEventListener("click", () => {
      this.pendingStaminaChange += Math.min(1, poolMaxStamina - poolCurrentStamina - this.pendingStaminaChange);
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
      this.updateInfoText(infoText);
      this.updateCheckboxes();
      this.updateActionButton(actionButton, warningIcon);
    });
    const applyContainer = minionsStaminaModal.createEl("div", { cls: "apply-container" });
    const applyRow = applyContainer.createEl("div", { cls: "apply-row" });
    applyRow.createEl("span", { text: "Apply" });
    const damageInput = applyRow.createEl("input", {
      type: "number",
      cls: "apply-input",
      attr: { size: 3 }
    });
    damageInput.value = "0";
    applyRow.createEl("span", { text: "damage to" });
    const minionCountInput = applyRow.createEl("input", {
      type: "number",
      cls: "apply-input",
      attr: { size: 3 }
    });
    minionCountInput.value = "1";
    minionCountInput.max = (_b = this.creature.instances) == null ? void 0 : _b.length.toString();
    minionCountInput.min = "0";
    applyRow.createEl("span", { text: "minions" });
    const applyDamageButton = applyRow.createEl("button", { cls: "apply-btn" });
    (0, import_obsidian8.setIcon)(applyDamageButton.createEl("div", { cls: "btn-icon" }), "sword");
    applyDamageButton.createEl("div", { cls: "btn-text", text: "Apply Damage" });
    applyDamageButton.addEventListener("click", () => {
      const damage = parseInt(damageInput.value);
      const minions = parseInt(minionCountInput.value);
      if (!isNaN(damage) && !isNaN(minions)) {
        const totalDamage = damage * minions;
        this.pendingStaminaChange -= totalDamage;
        this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
        this.updateInfoText(infoText);
        this.updateCheckboxes();
        this.updateActionButton(actionButton, warningIcon);
      }
    });
    const divider = minionsStaminaModal.createEl("div", { cls: "horizontal-divider" });
    const minionListContainer = minionsStaminaModal.createEl("div", { cls: "minion-list-container" });
    const infoText = minionListContainer.createEl("div", { cls: "info-text" });
    this.updateInfoText(infoText);
    this.creature.instances.forEach((instance) => {
      if (instance.isDead)
        return;
      const minionRow = minionListContainer.createEl("div", { cls: "minion-row" });
      const checkbox = minionRow.createEl("input", { type: "checkbox", cls: "minion-checkbox" });
      checkbox.addEventListener("change", () => {
        this.updateCheckboxes();
        this.updateActionButton(actionButton, warningIcon);
      });
      this.minionCheckboxes.push({ instance, checkbox });
      const minionName = minionRow.createEl("span", {
        text: `${this.creature.name} #${instance.id}`,
        cls: "minion-name"
      });
      minionName.addEventListener("click", () => {
        if (!checkbox.disabled) {
          checkbox.checked = !checkbox.checked;
          this.updateCheckboxes();
          this.updateActionButton(actionButton, warningIcon);
        }
      });
      const conditionsEl = minionRow.createEl("div", { cls: "minion-conditions" });
      this.buildConditionIcons(conditionsEl, instance, this.data, this.ctx);
    });
    const actionButtonContainer = minionsStaminaModal.createEl("div", { cls: "action-button-container" });
    const resetButton = actionButtonContainer.createEl("button", { cls: "reset-button" });
    (0, import_obsidian8.setIcon)(resetButton.createEl("div", { cls: "btn-icon" }), "undo");
    resetButton.createEl("div", { cls: "btn-text", text: "Reset" });
    resetButton.addEventListener("click", () => {
      this.pendingStaminaChange = 0;
      damageInput.value = "0";
      minionCountInput.value = "1";
      staminaValueDisplay.value = poolCurrentStamina.toString();
      this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
      this.updateInfoText(infoText);
      this.minionCheckboxes.forEach((item) => {
        item.checkbox.checked = false;
        item.checkbox.disabled = true;
      });
      this.updateCheckboxes();
      this.updateActionButton(actionButton, warningIcon);
    });
    const warningIcon = actionButtonContainer.createEl("div", { cls: "warning-icon" });
    (0, import_obsidian8.setIcon)(warningIcon, "alert-circle");
    warningIcon.style.display = "none";
    const actionButton = actionButtonContainer.createEl("button", { cls: "action-button" });
    this.updateActionButton(actionButton, warningIcon);
    actionButton.addEventListener("click", () => {
      const newStamina = poolCurrentStamina + this.pendingStaminaChange;
      const maxStamina = this.creature.instances.filter((inst) => !inst.isDead).length * minionMaxStamina;
      this.group.minion_stamina_pool = Math.min(maxStamina, Math.max(0, newStamina));
      const checkedMinions = this.minionCheckboxes.filter((item) => item.checkbox.checked);
      checkedMinions.forEach((item) => {
        item.instance.isDead = true;
      });
      this.updateCallback();
      this.close();
    });
    this.updateCheckboxes();
  }
  updateStaminaBar(staminaBarFillLeft, staminaBarFillRight) {
    var _a;
    const minionMaxStamina = this.creature.max_stamina;
    const aliveMinions = this.creature.instances.filter((inst) => !inst.isDead).length;
    const poolMaxStamina = aliveMinions * minionMaxStamina;
    const poolCurrentStamina = (_a = this.group.minion_stamina_pool) != null ? _a : poolMaxStamina;
    const newStamina = Math.min(poolMaxStamina, Math.max(0, poolCurrentStamina + this.pendingStaminaChange));
    const currentStaminaPercentage = poolCurrentStamina / poolMaxStamina * 100;
    const newStaminaPercentage = newStamina / poolMaxStamina * 100;
    const pendingChangePercentage = (newStamina - poolCurrentStamina) / poolMaxStamina * 100;
    if (this.pendingStaminaChange > 0) {
      staminaBarFillLeft.style.width = `${currentStaminaPercentage}%`;
      staminaBarFillLeft.style.left = "1px";
      staminaBarFillLeft.style.backgroundColor = "limegreen";
      staminaBarFillRight.style.width = `${pendingChangePercentage}%`;
      staminaBarFillRight.style.backgroundColor = "deepskyblue";
      staminaBarFillRight.style.borderRadius = "0 3px 3px 0";
    } else if (this.pendingStaminaChange < 0) {
      staminaBarFillLeft.style.width = `${newStaminaPercentage}%`;
      staminaBarFillLeft.style.left = "1px";
      staminaBarFillLeft.style.backgroundColor = "limegreen";
      staminaBarFillLeft.style.borderRadius = "3px 0 0 3px";
      staminaBarFillRight.style.width = `${this.pendingStaminaChange / poolMaxStamina * -100}%`;
      staminaBarFillRight.style.backgroundColor = "crimson";
      staminaBarFillRight.style.borderRadius = "3px 0 0 3px";
    } else {
      staminaBarFillLeft.style.width = `${currentStaminaPercentage}%`;
      staminaBarFillLeft.style.left = "1px";
      staminaBarFillLeft.style.backgroundColor = "limegreen";
      staminaBarFillLeft.style.borderRadius = "3px 3px 3px 3px";
      staminaBarFillRight.style.width = `0%`;
    }
    const staminaValueDisplay = this.contentEl.querySelector(".stamina-value-display");
    if (staminaValueDisplay) {
      staminaValueDisplay.value = newStamina.toString();
    }
  }
  updateInfoText(infoText) {
    var _a;
    const totalPendingDamage = -this.pendingStaminaChange;
    const minionMaxStamina = this.creature.max_stamina;
    const aliveMinions = this.creature.instances.filter((inst) => !inst.isDead).length;
    const poolMaxStamina = aliveMinions * minionMaxStamina;
    const poolCurrentStamina = (_a = this.group.minion_stamina_pool) != null ? _a : poolMaxStamina;
    const newStamina = poolCurrentStamina + this.pendingStaminaChange;
    const initialMinionsKilled = Math.floor((poolMaxStamina - poolCurrentStamina) / minionMaxStamina);
    const finalMinionsKilled = Math.floor((poolMaxStamina - newStamina) / minionMaxStamina);
    const minionsToKill = finalMinionsKilled - initialMinionsKilled;
    infoText.textContent = `${totalPendingDamage} damage will kill ${minionsToKill} minion(s). 
Select ${minionsToKill} minion(s) to kill.`;
  }
  updateActionButton(actionButton, warningIcon) {
    var _a;
    const staminaChange = this.pendingStaminaChange;
    const minionMaxStamina = this.creature.max_stamina;
    const aliveMinions = this.creature.instances.filter((inst) => !inst.isDead).length;
    const poolMaxStamina = aliveMinions * minionMaxStamina;
    const poolCurrentStamina = (_a = this.group.minion_stamina_pool) != null ? _a : poolMaxStamina;
    const newStamina = poolCurrentStamina + this.pendingStaminaChange;
    const initialMinionsKilled = Math.floor((poolMaxStamina - poolCurrentStamina) / minionMaxStamina);
    const finalMinionsKilled = Math.floor((poolMaxStamina - newStamina) / minionMaxStamina);
    const minionsToKill = finalMinionsKilled - initialMinionsKilled;
    const selectedMinions = this.minionCheckboxes.filter((item) => item.checkbox.checked).length;
    const disableActionButton = minionsToKill !== selectedMinions;
    let actionText = "";
    if (staminaChange < 0) {
      actionText += `Deal ${Math.abs(staminaChange)} damage`;
      if (minionsToKill > 0) {
        actionText += `, kill ${minionsToKill} minion(s)`;
      }
    } else if (staminaChange > 0) {
      actionText += `Heal ${staminaChange} stamina`;
    } else {
      actionText = "No Stamina Change";
    }
    actionButton.textContent = actionText;
    actionButton.toggleClass("disabled", staminaChange === 0 || disableActionButton);
    if (disableActionButton && minionsToKill > 0) {
      actionButton.setAttribute("title", `Select ${minionsToKill} minion(s) to kill`);
    } else {
      actionButton.removeAttribute("title");
    }
    if (staminaChange > 0) {
      warningIcon.style.display = "flex";
      warningIcon.setAttribute("title", "Typically minions are unable to regain stamina");
    } else {
      warningIcon.style.display = "none";
    }
  }
  updateCheckboxes() {
    var _a;
    const minionMaxStamina = this.creature.max_stamina;
    const aliveMinions = this.creature.instances.filter((inst) => !inst.isDead).length;
    const poolMaxStamina = aliveMinions * minionMaxStamina;
    const poolCurrentStamina = (_a = this.group.minion_stamina_pool) != null ? _a : poolMaxStamina;
    const newStamina = poolCurrentStamina + this.pendingStaminaChange;
    const initialMinionsKilled = Math.floor((poolMaxStamina - poolCurrentStamina) / minionMaxStamina);
    const finalMinionsKilled = Math.floor((poolMaxStamina - newStamina) / minionMaxStamina);
    const minionsToKill = finalMinionsKilled - initialMinionsKilled;
    if (newStamina <= 0) {
      this.minionCheckboxes.forEach((item) => {
        item.checkbox.checked = true;
        item.checkbox.disabled = true;
      });
      return;
    }
    if (minionsToKill <= 0) {
      this.minionCheckboxes.forEach((item) => {
        item.checkbox.checked = false;
        item.checkbox.disabled = true;
      });
    } else {
      const selectedCount = this.minionCheckboxes.filter((item) => item.checkbox.checked).length;
      this.minionCheckboxes.forEach((item) => {
        if (item.checkbox.checked) {
          item.checkbox.disabled = false;
        } else {
          item.checkbox.disabled = selectedCount >= minionsToKill;
        }
      });
    }
  }
  buildConditionIcons(container, character, data, ctx) {
    const conditions = character.conditions || [];
    const conditionManager = new ConditionManager();
    conditions.forEach((conditionEntry) => {
      let conditionKey;
      let conditionData = null;
      if (typeof conditionEntry === "string") {
        conditionKey = conditionEntry;
      } else if (typeof conditionEntry === "object" && conditionEntry.key) {
        conditionKey = conditionEntry.key;
        conditionData = conditionEntry;
      } else {
        return;
      }
      const condition = conditionManager.getAnyConditionByKey(conditionKey);
      if (condition) {
        const iconEl = container.createEl("div", { cls: "condition-icon" });
        (0, import_obsidian8.setIcon)(iconEl, condition.iconName);
        iconEl.title = condition.displayName;
        if (conditionData) {
          if (conditionData.color) {
            iconEl.style.color = conditionData.color;
          }
          if (conditionData.effect) {
            iconEl.classList.add(`condition-effect-${conditionData.effect}`);
          }
        }
        iconEl.addEventListener("click", () => {
          character.conditions = conditions.filter((entry) => entry !== conditionEntry);
          container.empty();
          this.buildConditionIcons(container, character, data, ctx);
          CodeBlocks.updateCodeBlock(this.app, data, ctx);
        });
      }
    });
  }
};

// src/model/StaminaBar.ts
var import_obsidian9 = require("obsidian");
var StaminaBar = class {
  static parseYaml(source) {
    let data;
    try {
      data = (0, import_obsidian9.parseYaml)(source);
    } catch (error) {
      throw new Error("Invalid YAML format: " + error.message);
    }
    return StaminaBar.parse(data);
  }
  static parse(data) {
    return new StaminaBar(
      data.max_stamina,
      data.current_stamina ? data.current_stamina : data.max_stamina,
      data.temp_stamina ? data.temp_stamina : 0,
      data.height ? data.height : 1
    );
  }
  // TODO - should this be in Hero and CreatureInstance instead?  probably, but those are interfaces
  static fromHero(hero) {
    return new StaminaBar(hero.max_stamina, hero.current_stamina, hero.temp_stamina, 1);
  }
  static fromCreature(being, creature) {
    return new StaminaBar(creature.max_stamina, being.current_stamina, being.temp_stamina, 1);
  }
  constructor(max_stamina, current_stamina, temp_stamina, height) {
    this.max_stamina = max_stamina;
    this.current_stamina = current_stamina;
    this.temp_stamina = temp_stamina;
    this.height = height;
  }
  updateHero(hero) {
    hero.max_stamina = this.max_stamina;
    hero.current_stamina = this.current_stamina;
    hero.temp_stamina = this.temp_stamina;
  }
  updateCreature(creature) {
    creature.current_stamina = this.current_stamina;
    creature.temp_stamina = this.temp_stamina;
  }
};

// src/drawSteelAdmonition/initiativeProcessor.ts
var InitiativeProcessor = class {
  constructor(app) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.app = app;
    this.conditionManager = new ConditionManager();
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-init-container" });
    try {
      const data = parseEncounterData(source);
      this.buildUI(container, data, ctx);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the Initiative Tracker properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message ds-container" });
    }
  }
  buildUI(container, data, ctx) {
    const topActionBar = container.createEl("div", { cls: "top-action-bar" });
    const resetRoundButton = topActionBar.createEl("button", {
      text: "Reset Round",
      cls: "reset-round-button"
    });
    resetRoundButton.addEventListener("click", () => {
      data.heroes.forEach((hero) => {
        hero.has_taken_turn = false;
      });
      data.enemy_groups.forEach((group) => {
        group.has_taken_turn = false;
      });
      container.empty();
      this.buildUI(container, data, ctx);
      CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
    });
    const resetEncounterButton = topActionBar.createEl("button", {
      text: "Reset Encounter State",
      cls: "reset-encounter-button"
    });
    resetEncounterButton.addEventListener("click", () => {
      new ResetEncounterModal(this.app, () => {
        resetEncounter(data);
        CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
      }).open();
    });
    const heroesContainer = container.createEl("div", { cls: "heroes-container" });
    heroesContainer.createEl("h3", { text: "Heroes" });
    data.heroes.forEach((hero) => {
      const heroContEl = heroesContainer.createEl("div", { cls: "hero-container" });
      this.buildCharacterRow(heroContEl, hero, data, ctx);
    });
    const enemiesContainer = container.createEl("div", { cls: "enemies-container" });
    const enemyHeader = enemiesContainer.createEl("div", { cls: "enemies-header" });
    enemyHeader.createEl("h3", { text: "Enemy Groups" });
    const maliceContainer = enemyHeader.createEl("div", { cls: "malice-container" });
    const maliceModifiers = maliceContainer.createEl("div", { cls: "malice-modifiers" });
    let maliceUp = maliceModifiers.createEl("div", { cls: "malice-modifier" });
    let maliceDown = maliceModifiers.createEl("div", { cls: "malice-modifier" });
    maliceContainer.createEl("div", { cls: "malice-text", text: "Malice: " + data.malice.value });
    (0, import_obsidian10.setIcon)(maliceUp, "chevron-up");
    (0, import_obsidian10.setIcon)(maliceDown, "chevron-down");
    maliceUp.addEventListener("click", () => {
      data.malice.value += 1;
      maliceContainer.setText("Malice: " + data.malice.value);
      CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
    });
    maliceDown.addEventListener("click", () => {
      data.malice.value -= 1;
      maliceContainer.setText("Malice: " + data.malice.value);
      CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
    });
    data.enemy_groups.forEach((group) => {
      const groupContEl = enemiesContainer.createEl("div", { cls: "enemy-group-container" });
      this.buildEnemyGroupRow(groupContEl, group, data, ctx);
    });
  }
  buildCharacterRow(container, character, data, ctx) {
    var _a, _b;
    const icon = container.createEl("div", { cls: "character-icon" });
    const turnIndicatorEl = icon.createEl("div", { cls: "turn-indicator" });
    turnIndicatorEl.title = "Toggle to mark turn taken";
    this.updateTurnIndicator(turnIndicatorEl, (_a = character.has_taken_turn) != null ? _a : false);
    turnIndicatorEl.addEventListener("click", () => {
      var _a2;
      if (this.isHero(character)) {
        character.has_taken_turn = !((_a2 = character.has_taken_turn) != null ? _a2 : false);
        this.updateTurnIndicator(turnIndicatorEl, character.has_taken_turn);
        CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
      }
    });
    const rowEl = container.createEl("div", { cls: "character-row" });
    const imageEl = rowEl.createEl("div", { cls: "character-image" });
    const imgSrcRaw = (_b = character.image) != null ? _b : null;
    Images.resolveImageSource(this.app, imgSrcRaw).then((imgSrc) => {
      imageEl.createEl("img", { attr: { src: imgSrc, alt: character.name } });
    }).catch(() => {
      imageEl.createEl("img", { attr: { src: DEFAULT_IMAGE_PATH, alt: character.name } });
    });
    const infoEl = rowEl.createEl("div", { cls: "character-info" });
    let displayName = character.name;
    infoEl.createEl("div", { cls: "character-name", text: displayName });
    const conditionsEl = infoEl.createEl("div", { cls: "character-conditions" });
    this.buildConditionIcons(conditionsEl, character, data, ctx);
    const rightContainer = rowEl.createEl("div", { cls: "character-right" });
    const healthEl = rightContainer.createEl("div", { cls: "character-health" });
    const staminaEl = healthEl.createEl("div", { cls: "character-stamina" });
    this.updateStaminaDisplay(staminaEl, character);
    staminaEl.addEventListener("click", () => {
      let staminaBar = StaminaBar.fromHero(character);
      const modal = new StaminaEditModal(this.app, staminaBar, true, character.name, () => {
        staminaBar.updateHero(character);
        this.updateStaminaDisplay(staminaEl, character);
        CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
      });
      modal.open();
    });
  }
  buildEnemyGroupRow(container, group, data, ctx) {
    var _a;
    const icon = container.createEl("div", { cls: "enemy-group-icon" });
    const turnIndicatorEl = icon.createEl("div", { cls: "turn-indicator" });
    turnIndicatorEl.title = "Toggle to mark turn taken";
    this.updateTurnIndicator(turnIndicatorEl, (_a = group.has_taken_turn) != null ? _a : false);
    turnIndicatorEl.addEventListener("click", () => {
      var _a2;
      group.has_taken_turn = !((_a2 = group.has_taken_turn) != null ? _a2 : false);
      this.updateTurnIndicator(turnIndicatorEl, group.has_taken_turn);
      CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
    });
    const groupEl = container.createEl("div", { cls: "enemy-group" });
    const groupHeader = groupEl.createEl("div", { cls: "group-header" });
    groupHeader.createEl("h4", { text: group.name });
    const detailRowContainer = groupEl.createEl("div", { cls: "creature-detail-row" });
    let selectedInstance = null;
    if (group.selectedInstanceKey != null) {
      for (let creatureIndex = 0; creatureIndex < group.creatures.length; creatureIndex++) {
        const creature = group.creatures[creatureIndex];
        if (creature.instances) {
          const instance = creature.instances.find((inst) => {
            const instanceKey = `${creatureIndex}-${inst.id}`;
            return instanceKey === group.selectedInstanceKey;
          });
          if (instance) {
            selectedInstance = { creature, instance };
            break;
          }
        }
      }
    }
    if (!selectedInstance) {
      for (const creature of group.creatures) {
        if (creature.instances && creature.instances.length > 0) {
          selectedInstance = { creature, instance: creature.instances[0] };
          break;
        }
      }
    }
    if (selectedInstance) {
      this.buildDetailedCreatureRow(
        detailRowContainer,
        selectedInstance.creature,
        selectedInstance.instance,
        data,
        ctx,
        group
      );
    }
    if (group.creatures.length === 1 && group.creatures[0].amount === 1) {
      return;
    }
    const instancesGrid = groupEl.createEl("div", { cls: "creature-instances-grid" });
    group.creatures.forEach((creature, creatureIndex) => {
      var _a2;
      (_a2 = creature.instances) == null ? void 0 : _a2.forEach((instance) => {
        var _a3;
        const cellEl = instancesGrid.createEl("div", { cls: "creature-instance-cell" });
        const instanceKey = `${creatureIndex}-${instance.id}`;
        if (group.selectedInstanceKey === instanceKey) {
          cellEl.addClass("selected");
        }
        const imgEl = cellEl.createEl("div", { cls: "instance-image" });
        const imgSrcRaw = (_a3 = creature.image) != null ? _a3 : null;
        Images.resolveImageSource(this.app, imgSrcRaw).then((imgSrc) => {
          imgEl.createEl("img", { attr: { src: imgSrc, alt: creature.name } });
        }).catch(() => {
          imgEl.createEl("img", { attr: { src: DEFAULT_IMAGE_PATH, alt: creature.name } });
        });
        const staminaEl = cellEl.createEl("div", { cls: "instance-stamina" });
        this.updateStaminaDisplay(staminaEl, instance, creature, group);
        cellEl.addEventListener("click", () => {
          instancesGrid.querySelectorAll(".creature-instance-cell").forEach((cell) => {
            cell.removeClass("selected");
          });
          cellEl.addClass("selected");
          detailRowContainer.empty();
          this.buildDetailedCreatureRow(detailRowContainer, creature, instance, data, ctx, group);
          group.selectedInstanceKey = instanceKey;
          CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
        });
        cellEl.addEventListener("dblclick", () => {
          if (group.is_squad && creature.squad_role === "minion") {
            const modal = new MinionStaminaPoolModal(this.app, group, creature, data, ctx, () => {
              container.empty();
              this.buildUI(container, data, ctx);
              CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
            });
            modal.open();
          } else {
            this.editCreatureStaminaModal(instance, creature, data, ctx, staminaEl, container).open();
          }
        });
      });
    });
  }
  buildDetailedCreatureRow(container, creature, instance, data, ctx, group) {
    var _a;
    container.addClass("character-row");
    const imageEl = container.createEl("div", { cls: "character-image" });
    const imgSrcRaw = (_a = creature.image) != null ? _a : null;
    Images.resolveImageSource(this.app, imgSrcRaw).then((imgSrc) => {
      imageEl.createEl("img", { attr: { src: imgSrc, alt: creature.name } });
    }).catch(() => {
      imageEl.createEl("img", { attr: { src: DEFAULT_IMAGE_PATH, alt: creature.name } });
    });
    const infoEl = container.createEl("div", { cls: "character-info" });
    infoEl.createEl("div", { cls: "character-name", text: `${creature.name} #${instance.id}` });
    const conditionsEl = infoEl.createEl("div", { cls: "character-conditions" });
    this.buildConditionIcons(conditionsEl, instance, data, ctx);
    const healthEl = container.createEl("div", { cls: "character-health" });
    const staminaEl = healthEl.createEl("div", { cls: "character-stamina" });
    if (group.is_squad && creature.squad_role === "minion") {
      this.updateStaminaDisplay(staminaEl, instance, creature, group);
      staminaEl.addEventListener("click", () => {
        const modal = new MinionStaminaPoolModal(this.app, group, creature, data, ctx, () => {
          container.empty();
          this.buildDetailedCreatureRow(container, creature, instance, data, ctx, group);
          CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
        });
        modal.open();
      });
    } else {
      this.updateStaminaDisplay(staminaEl, instance, creature, group);
      staminaEl.addEventListener("click", () => {
        this.editCreatureStaminaModal(instance, creature, data, ctx, staminaEl, container).open();
      });
    }
  }
  editCreatureStaminaModal(instance, creature, data, ctx, staminaEl, container) {
    const staminaBar = StaminaBar.fromCreature(instance, creature);
    return new StaminaEditModal(this.app, staminaBar, false, creature.name, () => {
      var _a;
      staminaBar.updateCreature(instance);
      this.updateStaminaDisplay(staminaEl, instance, creature);
      CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
      const gridCell = (_a = container.parentElement) == null ? void 0 : _a.querySelector(
        `.creature-instance-cell:nth-child(${instance.id}) .instance-stamina`
      );
      if (gridCell) {
        this.updateStaminaDisplay(gridCell, instance, creature);
      }
    });
  }
  updateTurnIndicator(el, hasTakenTurn) {
    el.empty();
    if (hasTakenTurn) {
      el.addClass("taken-turn");
      (0, import_obsidian10.setIcon)(el, "check");
    } else {
      el.removeClass("taken-turn");
      (0, import_obsidian10.setIcon)(el, "dot");
    }
  }
  updateStaminaDisplay(staminaEl, character, creature, group) {
    var _a, _b, _c, _d;
    if ((group == null ? void 0 : group.is_squad) && (creature == null ? void 0 : creature.squad_role) === "minion") {
      if (character.isDead) {
        staminaEl.textContent = `DEAD`;
        staminaEl.style.color = "crimson";
      } else {
        const currentStamina = (_a = group.minion_stamina_pool) != null ? _a : 0;
        staminaEl.textContent = `${currentStamina}/${creature.max_stamina * creature.amount} (${creature.max_stamina})`;
        staminaEl.style.color = "var(--text-normal)";
      }
    } else {
      const currentStamina = (_b = character.current_stamina) != null ? _b : 0;
      const tempStamina = (_c = character.temp_stamina) != null ? _c : 0;
      const maxStamina = this.isHero(character) ? character.max_stamina : (_d = creature == null ? void 0 : creature.max_stamina) != null ? _d : 0;
      let displayText = `${currentStamina}`;
      if (tempStamina > 0) {
        displayText += `(+${tempStamina})`;
      }
      displayText += `/${maxStamina}`;
      staminaEl.textContent = displayText;
      if (currentStamina < 0) {
        staminaEl.style.color = "red";
      } else if (tempStamina > 0) {
        staminaEl.style.color = "green";
      } else {
        staminaEl.style.color = "";
      }
    }
  }
  buildConditionIcons(container, character, data, ctx) {
    const conditions = character.conditions || [];
    conditions.forEach((conditionEntry) => {
      let conditionKey;
      let conditionData = null;
      if (typeof conditionEntry === "string") {
        conditionKey = conditionEntry;
      } else if (typeof conditionEntry === "object" && conditionEntry.key) {
        conditionKey = conditionEntry.key;
        conditionData = conditionEntry;
      } else {
        return;
      }
      const condition = this.conditionManager.getAnyConditionByKey(conditionKey);
      if (condition) {
        const iconEl = container.createEl("div", { cls: "condition-icon" });
        (0, import_obsidian10.setIcon)(iconEl, condition.iconName);
        iconEl.title = condition.displayName;
        if (conditionData) {
          if (conditionData.color) {
            iconEl.style.color = conditionData.color;
          }
          if (conditionData.effect) {
            iconEl.classList.add(`condition-effect-${conditionData.effect}`);
          }
        }
        iconEl.addEventListener("click", () => {
          character.conditions = conditions.filter((entry) => entry !== conditionEntry);
          container.empty();
          this.buildConditionIcons(container, character, data, ctx);
          CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
        });
      }
    });
    const addConditionEl = container.createEl("div", { cls: "add-condition-icon" });
    (0, import_obsidian10.setIcon)(addConditionEl, "plus-circle");
    addConditionEl.title = "Add Condition";
    addConditionEl.addEventListener("click", () => {
      const addConditionsModal = new AddConditionsModal(
        this.app,
        character,
        this.conditionManager,
        (newConditions) => {
          character.conditions = (character.conditions || []).concat(newConditions);
          container.empty();
          this.buildConditionIcons(container, character, data, ctx);
          CodeBlocks.updateInitiativeTracker(this.app, data, ctx);
        }
      );
      addConditionsModal.open();
    });
  }
  isHero(character) {
    return "isHero" in character ? character.isHero : false;
  }
};

// src/drawSteelAdmonition/negotiation/NegotiationTrackerProcessor.ts
var import_obsidian15 = require("obsidian");

// src/model/NegotiationData.ts
var import_obsidian11 = require("obsidian");
var NegotiationData = class {
  constructor(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    this.name = data.name;
    this.initial_patience = data.initial_patience;
    this.current_patience = (_b = (_a = data.current_patience) != null ? _a : data.initial_patience) != null ? _b : 5;
    this.initial_interest = data.initial_interest;
    this.current_interest = (_d = (_c = data.current_interest) != null ? _c : data.initial_interest) != null ? _d : 0;
    this.motivations = (_f = (_e = data.motivations) == null ? void 0 : _e.map((mot) => new Motivation(mot))) != null ? _f : [];
    this.pitfalls = (_h = (_g = data.pitfalls) == null ? void 0 : _g.map((pit) => new Pitfall(pit))) != null ? _h : [];
    this.currentArgument = data.currentArgument ? new CurrentArgument(data.currentArgument) : new CurrentArgument({});
    this.i5 = (_i = data.i5) != null ? _i : "Interest 5 result";
    this.i4 = (_j = data.i4) != null ? _j : "Interest 4 result";
    this.i3 = (_k = data.i3) != null ? _k : "Interest 3 result";
    this.i2 = (_l = data.i2) != null ? _l : "Interest 2 result";
    this.i1 = (_m = data.i1) != null ? _m : "Interest 1 result";
    this.i0 = (_n = data.i0) != null ? _n : "Interest 0 result";
  }
  setMotivationUsed(motivationName, used) {
    const mot = this.motivations.find((m) => m.name === motivationName);
    mot.hasBeenAppealedTo = used;
    if (used && this.currentArgument.motivationsUsed.contains(motivationName)) {
      this.currentArgument.reusedMotivation = true;
    }
    if (!used && this.currentArgument.motivationsUsed.contains(motivationName)) {
      let canSetReusedMotivationFlag = true;
      this.currentArgument.motivationsUsed.forEach((currentMotivation) => {
        let globalMotivation = this.motivations.find((m) => m.name === currentMotivation);
        if (globalMotivation && globalMotivation.hasBeenAppealedTo) {
          canSetReusedMotivationFlag = false;
        }
      });
      if (canSetReusedMotivationFlag) {
        this.currentArgument.reusedMotivation = false;
      }
    }
  }
  /**
   * Determines if any of the motivations used in the current argument have been reused.
   * @returns {boolean} True if any motivation has been reused; otherwise, false.
   */
  argumentReusesMotivation() {
    return this.currentArgument.motivationsUsed.some((motName) => {
      var _a;
      const mot = this.motivations.find((m) => m.name === motName);
      return (_a = mot == null ? void 0 : mot.hasBeenAppealedTo) != null ? _a : false;
    });
  }
  resetData() {
    this.current_patience = this.initial_patience;
    this.current_interest = this.initial_interest;
    this.motivations.forEach((m) => m.hasBeenAppealedTo = false);
    this.currentArgument.resetData();
  }
};
var CurrentArgument = class {
  constructor(data) {
    var _a, _b, _c, _d, _e;
    this.motivationsUsed = (_a = data.motivationsUsed) != null ? _a : [];
    this.pitfallsUsed = (_b = data.pitfallsUsed) != null ? _b : [];
    this.lieUsed = (_c = data.lieUsed) != null ? _c : false;
    this.sameArgumentUsed = (_d = data.sameArgumentUsed) != null ? _d : false;
    this.reusedMotivation = (_e = data.reusedMotivation) != null ? _e : false;
  }
  /**
   * Checks if any motivations have been used in the current argument.
   * @returns {boolean} True if motivations have been used; otherwise, false.
   */
  usesMotivation() {
    return this.motivationsUsed.length > 0;
  }
  /**
   * Checks if any pitfalls have been used in the current argument.
   * @returns {boolean} True if pitfalls have been used; otherwise, false.
   */
  usesPitfall() {
    return this.pitfallsUsed.length > 0;
  }
  resetData() {
    this.motivationsUsed = [];
    this.pitfallsUsed = [];
    this.lieUsed = false;
    this.sameArgumentUsed = false;
    this.reusedMotivation = false;
  }
};
var Motivation = class {
  constructor(data) {
    var _a, _b, _c, _d, _e;
    this.name = (_b = (_a = data.name) == null ? void 0 : _a.trim()) != null ? _b : "";
    this.reason = (_d = (_c = data.reason) == null ? void 0 : _c.trim()) != null ? _d : "";
    this.hasBeenAppealedTo = (_e = data.hasBeenAppealedTo) != null ? _e : false;
  }
};
var Pitfall = class {
  constructor(data) {
    var _a, _b, _c, _d;
    this.name = (_b = (_a = data.name) == null ? void 0 : _a.trim()) != null ? _b : "";
    this.reason = (_d = (_c = data.reason) == null ? void 0 : _c.trim()) != null ? _d : "";
  }
};
function parseNegotiationData(source) {
  let data;
  try {
    data = (0, import_obsidian11.parseYaml)(source);
  } catch (error) {
    throw new Error("Invalid YAML format: " + error.message);
  }
  return new NegotiationData(data);
}

// src/drawSteelAdmonition/negotiation/PatienceInterestView.ts
var PatienceInterestView = class {
  constructor(app, data, ctx) {
    this.app = app;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    this.addPatience(parent);
    this.addInterest(parent);
  }
  // Add Patience Tracker
  addPatience(parent) {
    const patienceCont = parent.createEl("div", { cls: "ds-nt-patience-container" });
    patienceCont.createEl("div", { cls: "ds-nt-patience-label", text: "Patience" });
    const bubbleCont = patienceCont.createEl("div", { cls: "ds-nt-patience-bubble-container" });
    for (let i = 0; i <= 5; i++) {
      const bubble = bubbleCont.createEl("div", {
        cls: `ds-nt-patience-bubble ds-nt-patience-bubble-${i}`,
        text: `${i}`
      });
      bubble.addEventListener("click", () => this.setPatience(i, parent));
    }
    if (this.data.current_patience != null) {
      this.setPatience(this.data.current_patience, parent);
    }
  }
  // Set Patience Level
  setPatience(newPatience, container) {
    for (let i = 0; i <= 5; i++) {
      const bubble = container.querySelector(`.ds-nt-patience-bubble-${i}`);
      if (i > newPatience) {
        bubble.classList.remove("ds-nt-patience-selected");
      } else {
        bubble.classList.add("ds-nt-patience-selected");
      }
    }
    this.data.current_patience = newPatience;
    CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
  }
  // Add Interest Tracker
  addInterest(parent) {
    var _a;
    const interestCont = parent.createEl("div", { cls: "ds-nt-interest-container" });
    interestCont.createEl("div", { cls: "ds-nt-interest-header", text: "Interest" });
    const offerCont = interestCont.createEl("div", { cls: "ds-nt-interest-offer-container" });
    for (let i = 5; i >= 0; i--) {
      const iLine = offerCont.createEl("div", { cls: `ds-nt-interest-line ds-nt-interest-${i}-line` });
      const label = iLine.createEl("div", { cls: `ds-nt-interest-label ds-nt-interest-${i}-label`, text: `${i}` });
      label.addEventListener("click", () => this.setInterest(i, parent));
      const offerText = (_a = this.data[`i${i}`]) != null ? _a : `Offer at Interest ${i}`;
      iLine.createEl("div", { cls: `ds-nt-interest-offer ds-nt-interest-${i}-offer`, text: offerText });
    }
    if (this.data.current_interest != null) {
      this.setInterest(this.data.current_interest, parent);
    }
  }
  // Set Interest Level
  setInterest(newInterest, container) {
    for (let i = 0; i <= 5; i++) {
      const line = container.querySelector(`.ds-nt-interest-${i}-line`);
      const offer = line.querySelector(`.ds-nt-interest-offer`);
      if (i > newInterest) {
        line.classList.remove("ds-nt-interest-selected");
      } else {
        line.classList.add("ds-nt-interest-selected");
      }
      if (i < newInterest) {
        offer.classList.add("ds-nt-interest-faded");
      } else {
        offer.classList.remove("ds-nt-interest-faded");
      }
      if (i === newInterest) {
        line.classList.add("ds-nt-interest-current");
      } else {
        line.classList.remove("ds-nt-interest-current");
      }
    }
    this.data.current_interest = newInterest;
    CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
  }
};

// src/drawSteelAdmonition/negotiation/MotivationsPitfallsView.ts
var MotivationsPitfallsView = class {
  constructor(app, data, ctx) {
    this.app = app;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    this.addMotivations(parent);
    this.addPitfalls(parent);
  }
  // Add Motivations
  addMotivations(parent) {
    if (this.data.motivations.length > 0) {
      const motivationsCont = parent.createEl("div", { cls: "ds-nt-motivations" });
      motivationsCont.createEl("div", { cls: "ds-nt-details-header ds-nt-motivation-header", text: "Motivations" });
      const motivationList = motivationsCont.createEl("div", { cls: "ds-nt-motivation-list" });
      this.data.motivations.forEach((mot) => {
        var _a;
        const label = motivationList.createEl("label", { cls: "ds-nt-details-label ds-nt-motivation-label" });
        label.title = "Check Motivations that have already been appealed to.";
        const checkbox = label.createEl("input", { cls: "ds-nt-details-checkbox ds-nt-motivation-checkbox", type: "checkbox" });
        checkbox.checked = (_a = mot.hasBeenAppealedTo) != null ? _a : false;
        label.createEl("span", { cls: "ds-nt-details-name ds-nt-motivation-name", text: mot.name + ": " });
        label.createEl("span", { cls: "ds-nt-details-reason ds-nt-motivation-reason", text: mot.reason });
        checkbox.addEventListener("change", () => {
          this.data.setMotivationUsed(mot.name, checkbox.checked);
          CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
        });
      });
    }
  }
  // Add Pitfalls
  addPitfalls(parent) {
    if (this.data.pitfalls.length > 0) {
      const pitfallsCont = parent.createEl("div", { cls: "ds-nt-pitfalls" });
      pitfallsCont.createEl("div", { cls: "ds-nt-details-header ds-nt-pitfall-header", text: "Pitfalls" });
      const pitfallList = pitfallsCont.createEl("div", { cls: "ds-nt-pitfall-list" });
      this.data.pitfalls.forEach((pit) => {
        const label = pitfallList.createEl("label", { cls: "ds-nt-details-label ds-nt-pitfall-label" });
        label.createEl("span", { cls: "ds-nt-details-name ds-nt-pitfall-name", text: pit.name + ": " });
        label.createEl("span", { cls: "ds-nt-details-reason ds-nt-pitfall-reason", text: pit.reason });
      });
    }
  }
};

// src/drawSteelAdmonition/negotiation/ArgumentView.ts
var import_obsidian14 = require("obsidian");

// src/model/powerRoll.ts
var PowerRollTiers = class {
  constructor(t1, t2, t3, crit) {
    this.t1 = t1;
    this.t2 = t2;
    this.t3 = t3;
    this.crit = crit;
  }
};

// src/model/ArgumentPowerRolls.ts
var ArgumentPowerRoll = class {
  constructor(t1, t2, t3, crit) {
    this.t1 = t1;
    this.t2 = t2;
    this.t3 = t3;
    this.crit = crit;
  }
  static build(usedMotivation, usedPitfall, caughtLying, reusedMotivation, sameArgument) {
    let result = ArgumentPowerRoll.buildBaseline(usedMotivation, usedPitfall, reusedMotivation, sameArgument);
    if (caughtLying) {
      if (result.t1.interest <= 0)
        result.t1.interest -= 1;
      if (result.t2.interest <= 0)
        result.t2.interest -= 1;
      if (result.t3.interest <= 0)
        result.t3.interest -= 1;
      if (result.crit.interest <= 0)
        result.crit.interest -= 1;
    }
    return result;
  }
  static buildBaseline(usedMotivation, usedPitfall, reusedMotivation, sameArgument) {
    if (usedPitfall) {
      return new ArgumentPowerRoll(
        new ArgumentResult(-1, -1),
        new ArgumentResult(-1, -1),
        new ArgumentResult(-1, -1),
        new ArgumentResult(-1, -1)
      );
    }
    if (reusedMotivation) {
      return new ArgumentPowerRoll(
        new ArgumentResult(0, -1),
        new ArgumentResult(0, -1),
        new ArgumentResult(0, -1),
        new ArgumentResult(0, -1)
      );
    }
    if (usedMotivation) {
      return new ArgumentPowerRoll(
        new ArgumentResult(0, -1),
        new ArgumentResult(1, -1),
        new ArgumentResult(1, 0),
        new ArgumentResult(1, 0)
      );
    }
    if (sameArgument) {
      return new ArgumentPowerRoll(
        new ArgumentResult(-1, -1),
        new ArgumentResult(-1, -1),
        new ArgumentResult(-1, -1),
        new ArgumentResult(-1, -1)
      );
    }
    return new ArgumentPowerRoll(
      new ArgumentResult(-1, -1),
      new ArgumentResult(0, -1),
      new ArgumentResult(1, -1),
      new ArgumentResult(1, 0)
    );
  }
  toPowerRollTiers() {
    return new PowerRollTiers(
      this.t1.toString(),
      this.t2.toString(),
      this.t3.toString(),
      this.crit.toString()
    );
  }
};
var ArgumentResult = class {
  constructor(interest, patience, other) {
    this.toString = () => {
      let result = "";
      if (this.interest != 0) {
        result += `${this.interest > 0 ? "+" : ""}${this.interest} Interest`;
      }
      if (this.patience != 0) {
        if (result != "") {
          result += ", ";
        }
        result += `${this.patience > 0 ? "+" : ""}${this.patience} Patience`;
      }
      if (this.other != "") {
        if (result != "") {
          result += ", ";
        }
        result += this.other;
      }
      if (result == "") {
        result = "No effect";
      }
      return result;
    };
    this.interest = interest;
    this.patience = patience;
    this.other = other != null ? other : "";
  }
};

// src/utils/common.ts
var import_obsidian12 = require("obsidian");
function labeledIcon(iconName, label, parent) {
  const container = parent.createEl("div", { cls: "ds-labeled-icon" });
  (0, import_obsidian12.setIcon)(container.createEl("div", { cls: "icon" }), iconName);
  container.createEl("div", { cls: "text", text: label });
}

// src/drawSteelAdmonition/ability/PowerRollEffectView.ts
var import_obsidian13 = require("obsidian");
var PowerRollEffectView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const container = parent.createEl("div", { cls: "ds-pr-effect-container" });
    if (this.data.roll) {
      const typeContainer = container.createEl("div", { cls: "ability-detail-line pr-roll-line" });
      this.renderMD(this.ctx, this.data.roll, typeContainer.createEl("span", { cls: "ability-roll-value ds-multiline" }));
    }
    if (this.data.t1) {
      const t1Container = container.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-1-line" });
      PowerRollEffectView.tier1Key(t1Container);
      this.renderMD(this.ctx, this.data.t1, t1Container.createEl("span", { cls: "pr-tier-value pr-tier-1-value ds-multiline" }));
    }
    if (this.data.t2) {
      const t2Container = container.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-2-line" });
      PowerRollEffectView.tier2Key(t2Container);
      this.renderMD(this.ctx, this.data.t2, t2Container.createEl("span", { cls: "pr-tier-value pr-tier-2-value ds-multiline" }));
    }
    if (this.data.t3) {
      const t3Container = container.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-3-line" });
      PowerRollEffectView.tier3Key(t3Container);
      this.renderMD(this.ctx, this.data.t3, t3Container.createEl("span", { cls: "pr-tier-value pr-tier-3-value ds-multiline" }));
    }
    if (this.data.crit) {
      const critContainer = container.createEl("div", { cls: "ability-detail-line pr-tier-line pr-crit-line" });
      PowerRollEffectView.critKey(critContainer);
      this.renderMD(this.ctx, this.data.crit, critContainer.createEl("span", { cls: "pr-tier-value pr-crit-value ds-multiline" }));
    }
  }
  // TODO - this doesnt belong here?
  renderMD(ctx, markdown, el) {
    el.addClass("ability-inline-p");
    import_obsidian13.MarkdownRenderer.render(this.plugin.app, markdown, el, ctx.sourcePath, this.plugin);
  }
  static tier1Key(parentElement) {
    const container = parentElement.createEl("div", { cls: "tier-key-container t1-key-container" });
    const body = container.createEl("div", { cls: "t1-key-body" });
    body.createEl("div", { cls: "t1-key-body-text", text: "\u226411" });
  }
  static tier2Key(parentElement) {
    const container = parentElement.createEl("div", { cls: "tier-key-container t2-key-container" });
    const body = container.createEl("div", { cls: "t2-key-body" });
    body.createEl("div", { cls: "t2-key-body-text", text: "12-16" });
  }
  static tier3Key(parentElement) {
    const container = parentElement.createEl("div", { cls: "tier-key-container t3-key-container" });
    const body = container.createEl("div", { cls: "t3-key-body" });
    body.createEl("div", { cls: "t3-key-body-text", text: "17+" });
  }
  static critKey(parentElement) {
    const container = parentElement.createEl("div", { cls: "tier-key-container crit-key-container" });
    const body = container.createEl("div", { cls: "crit-key-body" });
    body.createEl("div", { cls: "crit-key-body-text", text: "crit" });
  }
};

// src/drawSteelAdmonition/negotiation/ArgumentView.ts
var ArgumentView = class {
  // Used for selecting power roll
  constructor(app, data, ctx) {
    this.selectedPowerRollTier = null;
    this.app = app;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent, root) {
    this.populateArgumentTab(parent, root);
  }
  populateArgumentTab(argumentContainer, root) {
    const argumentBody = argumentContainer.createEl("div", { cls: "ds-nt-argument-body" });
    const argModifiers = argumentBody.createEl("div", { cls: "ds-nt-argument-modifiers" });
    this.buildMotivationView(argModifiers);
    this.buildPitfallsView(argModifiers);
    this.buildOtherModsView(argumentBody);
    const argumentPowerRoll = ArgumentPowerRoll.build(
      this.data.currentArgument.usesMotivation(),
      this.data.currentArgument.usesPitfall(),
      this.data.currentArgument.lieUsed,
      this.data.currentArgument.reusedMotivation,
      this.data.currentArgument.sameArgumentUsed
    );
    this.buildPowerRoll(argumentBody, argumentPowerRoll);
    const footer = argumentContainer.createEl("div", { cls: "ds-nt-argument-footer" });
    this.completeButton = footer.createEl("button", { cls: "ds-nt-complete-argument-button" });
    this.completeButton.title = "Resolve the Argument using the current state of motivations, pitfalls, etc. \nRequires Power Roll tier to be selected.";
    labeledIcon("messages-square", "Complete Argument", this.completeButton);
    this.completeButton.disabled = true;
    this.completeButton.addEventListener("click", () => this.completeArgument());
  }
  buildMotivationView(argModifiers) {
    const motContainer = argModifiers.createEl("div", { cls: "ds-nt-argument-modifier-motivations" });
    if (this.data.motivations.length > 0) {
      const motHeader = motContainer.createEl("div", {
        cls: "ds-nt-argument-modifier-motivation-header",
        text: "Appeals to Motivation"
      });
      (0, import_obsidian14.setTooltip)(motHeader, "If the Heroes appeal to a Motivation (w/o a Pitfall): Difficulty of the Argument Test is Easy.");
      this.data.motivations.forEach((mot) => {
        var _a;
        const motLine = motContainer.createEl("div", { cls: "ds-nt-argument-modifier-motivation-line" });
        const motLabel = motLine.createEl("label", { cls: "ds-nt-argument-modifier-motivation-label" });
        motLabel.classList.toggle("ds-nt-arg-motivation-used", (_a = mot.hasBeenAppealedTo) != null ? _a : false);
        if (mot.hasBeenAppealedTo) {
          (0, import_obsidian14.setTooltip)(motLabel, "This Motivation was used in a previous Argument.");
        } else {
          (0, import_obsidian14.setTooltip)(motLabel, "");
        }
        const motCB = motLabel.createEl("input", {
          cls: "ds-nt-argument-modifier-motivation-checkbox",
          type: "checkbox"
        });
        motCB.checked = this.data.currentArgument.motivationsUsed.includes(mot.name);
        motLabel.createSpan({ text: mot.name });
        motCB.addEventListener("change", () => {
          if (motCB.checked) {
            if (!this.data.currentArgument.motivationsUsed.includes(mot.name)) {
              this.data.currentArgument.motivationsUsed.push(mot.name);
            }
            if (mot.hasBeenAppealedTo) {
              this.data.currentArgument.reusedMotivation = true;
            }
          } else {
            const index = this.data.currentArgument.motivationsUsed.indexOf(mot.name);
            if (index > -1) {
              this.data.currentArgument.motivationsUsed.splice(index, 1);
              this.data.currentArgument.reusedMotivation = this.data.argumentReusesMotivation();
            }
          }
          CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
        });
      });
    }
  }
  buildPitfallsView(argModifiers) {
    const pitContainer = argModifiers.createEl("div", { cls: "ds-nt-argument-modifier-pitfalls" });
    if (this.data.pitfalls.length > 0) {
      const pitHeader = pitContainer.createEl("div", {
        cls: "ds-nt-argument-modifier-pitfall-header",
        text: "Mentions Pitfall"
      });
      pitHeader.title = "If the Heroes mention a Pitfall: Argument fails and the NPC may warn Heroes.";
      this.data.pitfalls.forEach((pit) => {
        const pitLine = pitContainer.createEl("div", { cls: "ds-nt-argument-modifier-pitfall-line" });
        const pitLabel = pitLine.createEl("label", { cls: "ds-nt-argument-modifier-pitfall-label" });
        const pitCB = pitLabel.createEl("input", {
          cls: "ds-nt-argument-modifier-pitfall-checkbox",
          type: "checkbox"
        });
        pitCB.checked = this.data.currentArgument.pitfallsUsed.includes(pit.name);
        pitLabel.createSpan({ text: pit.name });
        pitCB.addEventListener("change", () => {
          if (pitCB.checked) {
            if (!this.data.currentArgument.pitfallsUsed.includes(pit.name)) {
              this.data.currentArgument.pitfallsUsed.push(pit.name);
            }
          } else {
            const index = this.data.currentArgument.pitfallsUsed.indexOf(pit.name);
            if (index > -1) {
              this.data.currentArgument.pitfallsUsed.splice(index, 1);
            }
          }
          CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
        });
      });
    }
  }
  buildOtherModsView(argModifiers) {
    const otherContainer = argModifiers.createEl("div", { cls: "ds-nt-argument-modifier-other" });
    const reuseMotivationLine = otherContainer.createEl("div", { cls: "ds-nt-argument-modifier-line ds-nt-argument-modifier-reuse-motivation-line" });
    reuseMotivationLine.title = "If the Heroes try to appeal to a Motivation multiple times: Interest remains and Patience decreases by 1.";
    const reuseMotivationLabel = reuseMotivationLine.createEl("label", { cls: "ds-nt-argument-modifier-reuse-motivation-label" });
    const reuseMotivationCheckbox = reuseMotivationLabel.createEl("input", {
      cls: "ds-nt-argument-modifier-reuse-motivation-checkbox",
      type: "checkbox"
    });
    reuseMotivationCheckbox.disabled = !this.data.argumentReusesMotivation();
    reuseMotivationCheckbox.checked = !reuseMotivationCheckbox.disabled && this.data.currentArgument.reusedMotivation;
    reuseMotivationLabel.createSpan({
      cls: "ds-nt-argument-modifier-reuse-motivation-text",
      text: "Reuses a Motivation that has already been appealed to"
    });
    reuseMotivationCheckbox.addEventListener("change", () => {
      this.data.currentArgument.reusedMotivation = reuseMotivationCheckbox.checked;
      CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
    });
    const lieLine = otherContainer.createEl("div", { cls: "ds-nt-argument-modifier-line ds-nt-argument-modifier-lie-line" });
    lieLine.title = "If the NPC catches a lie: Arguments that fail to increase Interest will lose an additional Interest.";
    const lieLabel = lieLine.createEl("label", { cls: "ds-nt-argument-modifier-lie-label" });
    const lieCheckbox = lieLabel.createEl("input", {
      cls: "ds-nt-argument-modifier-lie-checkbox",
      type: "checkbox"
    });
    lieCheckbox.checked = this.data.currentArgument.lieUsed;
    lieLabel.createSpan({ text: "NPC caught a lie and is offended" });
    lieCheckbox.addEventListener("change", () => {
      this.data.currentArgument.lieUsed = lieCheckbox.checked;
      CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
    });
    const sameArgLine = otherContainer.createEl("div", { cls: "ds-nt-argument-modifier-line ds-nt-argument-modifier-same-arg-line" });
    sameArgLine.title = "If the Heroes try to use the same Argument (w/o Motivation): Test automatically gets tier-1 result.";
    const sameArgLabel = sameArgLine.createEl("label", { cls: "ds-nt-argument-modifier-same-arg-label" });
    const sameArgCheckbox = sameArgLabel.createEl("input", {
      cls: "ds-nt-argument-modifier-same-arg-checkbox",
      type: "checkbox"
    });
    sameArgCheckbox.disabled = this.data.currentArgument.usesMotivation();
    sameArgCheckbox.checked = this.data.currentArgument.sameArgumentUsed;
    sameArgLabel.createSpan({
      cls: "ds-nt-argument-modifier-same-arg-text",
      text: "Argument has already been made (w/o Motivation)"
    });
    sameArgCheckbox.addEventListener("change", () => {
      this.data.currentArgument.sameArgumentUsed = sameArgCheckbox.checked;
      CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
    });
  }
  buildPowerRoll(argumentBody, argumentPowerRoll) {
    const argPowerRoll = argumentBody.createEl("div", { cls: "ds-nt-argument-power-roll" });
    const typeContainer = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-roll-line" });
    typeContainer.createEl("span", { cls: "ability-roll-value", text: "Power Roll + Reason, Intuition, or Presence" });
    const t1Container = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-1-line" });
    PowerRollEffectView.tier1Key(t1Container);
    t1Container.createEl("span", { cls: "pr-tier-value pr-tier-1-value", text: argumentPowerRoll.t1.toString() });
    const t2Container = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-2-line" });
    PowerRollEffectView.tier2Key(t2Container);
    t2Container.createEl("span", { cls: "pr-tier-value pr-tier-2-value", text: argumentPowerRoll.t2.toString() });
    const t3Container = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-3-line" });
    PowerRollEffectView.tier3Key(t3Container);
    t3Container.createEl("span", { cls: "pr-tier-value pr-tier-3-value", text: argumentPowerRoll.t3.toString() });
    const critContainer = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-tier-line pr-crit-line" });
    PowerRollEffectView.critKey(critContainer);
    critContainer.createEl("span", { cls: "pr-tier-value pr-crit-value", text: argumentPowerRoll.crit.toString() });
    const containers = [
      { container: t1Container, result: argumentPowerRoll.t1 },
      { container: t2Container, result: argumentPowerRoll.t2 },
      { container: t3Container, result: argumentPowerRoll.t3 },
      { container: critContainer, result: argumentPowerRoll.crit }
    ];
    containers.forEach((item) => {
      item.container.addEventListener("click", () => {
        if (this.selectedPowerRollTier === item.result) {
          this.selectedPowerRollTier = null;
        } else {
          this.selectedPowerRollTier = item.result;
        }
        containers.forEach((c) => {
          if (c.container === item.container && this.selectedPowerRollTier === item.result) {
            c.container.classList.add("active");
          } else {
            c.container.classList.remove("active");
          }
        });
        this.updateCompleteButtonState();
      });
    });
  }
  updateCompleteButtonState() {
    if (this.completeButton) {
      this.completeButton.disabled = this.selectedPowerRollTier == null;
    }
  }
  completeArgument() {
    this.data.currentArgument.motivationsUsed.forEach((motName) => {
      const mot = this.data.motivations.find((m) => m.name === motName);
      if (mot) {
        mot.hasBeenAppealedTo = true;
      }
    });
    if (this.selectedPowerRollTier) {
      this.data.current_interest += this.selectedPowerRollTier.interest;
      this.data.current_patience += this.selectedPowerRollTier.patience;
    }
    this.selectedPowerRollTier = null;
    this.updateCompleteButtonState();
    this.data.currentArgument.resetData();
    CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
  }
};

// src/drawSteelAdmonition/negotiation/LearnMoreView.ts
var _LearnMoreView = class {
  constructor(app, data, ctx) {
    this.app = app;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const learnMoreBody = parent.createEl("div", { cls: "ds-nt-learn-more-body" });
    learnMoreBody.createEl("p", { text: "If the heroes want to learn one of the NPC\u2019s motivations or pitfalls, a hero can make the following test while interacting with the NPC during the negotiation. After this test is made, the heroes can\u2019t make another test to determine the same NPC\u2019s motivations or pitfalls until they make an argument to the NPC or the negotiation ends." });
    this.buildPowerRoll(learnMoreBody);
  }
  buildPowerRoll(parent) {
    const argPowerRoll = parent.createEl("div", { cls: "ds-nt-argument-power-roll" });
    const typeContainer = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-roll-line" });
    typeContainer.createEl("span", { cls: "ability-roll-value", text: "Power Roll + Reason, Intuition, or Presence" });
    const t1Container = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-1-line" });
    PowerRollEffectView.tier1Key(t1Container);
    t1Container.createEl("span", { cls: "pr-tier-value pr-tier-1-value", text: _LearnMoreView.learnMorePowerRoll.t1 });
    const t2Container = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-2-line" });
    PowerRollEffectView.tier2Key(t2Container);
    t2Container.createEl("span", { cls: "pr-tier-value pr-tier-2-value", text: _LearnMoreView.learnMorePowerRoll.t2 });
    const t3Container = argPowerRoll.createEl("div", { cls: "ability-detail-line pr-tier-line pr-tier-3-line" });
    PowerRollEffectView.tier3Key(t3Container);
    t3Container.createEl("span", { cls: "pr-tier-value pr-tier-3-value", text: _LearnMoreView.learnMorePowerRoll.t3 });
  }
};
var LearnMoreView = _LearnMoreView;
LearnMoreView.learnMorePowerRoll = new PowerRollTiers(
  "The hero learns no information regarding the NPC\u2019s motivations or pitfalls, and the NPC realizes the hero is trying to read them and becomes annoyed. As a consequence, the NPC\u2019s patience is reduced by 1.",
  "The hero learns no information regarding the NPC\u2019s motivations or pitfalls.",
  "The hero learns one of the NPC\u2019s motivations or pitfalls (their choice).",
  ""
);

// src/drawSteelAdmonition/negotiation/NegotiationTrackerProcessor.ts
var NegotiationTrackerProcessor = class {
  constructor(app) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.app = app;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-nt-container ds-container" });
    try {
      this.ctx = ctx;
      this.data = parseNegotiationData(source);
      this.buildUI(container);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the Negotiation Tracker Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message" });
    }
  }
  buildUI(container) {
    if (!this.data.currentArgument) {
      this.data.currentArgument = {
        motivationsUsed: [],
        pitfallsUsed: [],
        lieUsed: false,
        sameArgumentUsed: false,
        reusedMotivation: false
      };
    }
    const nameContainer = container.createEl("div", { cls: "ds-nt-name-line" });
    const name = this.data.name;
    const title = name ? "Negotiation: " + name.trim() : "Negotiation";
    nameContainer.createEl("span", { cls: "ds-nt-name-value", text: "Negotiation: " + name.trim() });
    const menu = nameContainer.createEl("div", { cls: "ds-nt-settings-menu" });
    (0, import_obsidian15.setIcon)(menu, "more-vertical");
    menu.addEventListener("click", (event) => {
      const menu2 = new import_obsidian15.Menu();
      menu2.addItem(
        (item) => item.setTitle("Reset Negotiation").setIcon("rotate-ccw").onClick(() => {
          new import_obsidian15.Notice("Negotiation reset to initial state");
          this.data.resetData();
          CodeBlocks.updateNegotiationTracker(this.app, this.data, this.ctx);
        })
      );
      menu2.showAtMouseEvent(event);
    });
    const trackerContainer = container.createEl("div", { cls: "ds-nt-tracker-container" });
    new PatienceInterestView(this.app, this.data, this.ctx).build(trackerContainer);
    this.addActions(trackerContainer, container);
    const details = container.createEl("div", { cls: "ds-nt-details" });
    new MotivationsPitfallsView(this.app, this.data, this.ctx).build(details);
  }
  // Add Actions with Tabs
  addActions(parent, root) {
    const actionsContainer = parent.createEl("div", { cls: "ds-nt-actions-container" });
    const actionTab = actionsContainer.createEl("div", { cls: "ds-nt-action-tabs" });
    const argumentTab = actionTab.createEl("div", { cls: "ds-nt-action-tab ds-nt-argument-tab active" });
    labeledIcon("message-circle", "Make an Argument", argumentTab);
    const learnMoreTab = actionTab.createEl("div", { cls: "ds-nt-action-tab ds-nt-learn-more-tab" });
    labeledIcon("help-circle", "Learn Motivation/Pitfall", learnMoreTab);
    const argumentContainer = actionsContainer.createEl("div", { cls: "ds-nt-action-container ds-nt-argument-container active" });
    const learnMoreContainer = actionsContainer.createEl("div", { cls: "ds-nt-action-container ds-nt-learn-more-container" });
    argumentTab.addEventListener("click", () => {
      argumentTab.classList.add("active");
      learnMoreTab.classList.remove("active");
      argumentContainer.classList.add("active");
      learnMoreContainer.classList.remove("active");
    });
    learnMoreTab.addEventListener("click", () => {
      learnMoreTab.classList.add("active");
      argumentTab.classList.remove("active");
      learnMoreContainer.classList.add("active");
      argumentContainer.classList.remove("active");
    });
    new ArgumentView(this.app, this.data, this.ctx).build(argumentContainer, root);
    new LearnMoreView(this.app, this.data, this.ctx).build(learnMoreContainer);
  }
};

// src/model/StatblockData.ts
var import_obsidian18 = require("obsidian");

// src/model/Ability.ts
var import_obsidian17 = require("obsidian");

// src/drawSteelAdmonition/ability/MundaneEffectView.ts
var import_obsidian16 = require("obsidian");
var MundaneEffectView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    var _a;
    const container = parent.createEl("div", { cls: "ds-effect-container" });
    const cost = this.data.cost ? " (" + ((_a = this.data.cost) == null ? void 0 : _a.trim()) + ")" : "";
    let text = this.data.name ? this.data.name + cost : cost;
    text = text ? text + ": " : "";
    container.createEl("span", { cls: "ability-detail-key pr-effect-key", text });
    this.renderMD(this.ctx, this.data.effect, container.createEl("span", { cls: "pr-detail-value pr-effect-value ds-multiline" }));
  }
  // TODO - this doesnt belong here?
  renderMD(ctx, markdown, el) {
    el.addClass("ability-inline-p");
    import_obsidian16.MarkdownRenderer.render(this.plugin.app, markdown, el, ctx.sourcePath, this.plugin);
  }
};

// src/model/Effect.ts
var Effect = class {
  static parseAll(data) {
    if (!data) {
      return [];
    }
    if (!Array.isArray(data)) {
      throw new Error("Expected effects to be an array");
    }
    let effects = [];
    for (let entry of data) {
      if (entry.roll) {
        effects.push(new PowerRollEffect(entry));
      } else if (entry.name && entry.effect) {
        effects.push(MundaneEffect.parse(entry));
      } else if (typeof entry === "string") {
        effects.push(MundaneEffect.nameless(entry));
      } else {
        effects.push(MundaneEffect.parseKeyValue(entry));
      }
    }
    return effects;
  }
};
var PowerRollEffect = class extends Effect {
  constructor(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super();
    this.roll = data.roll;
    this.t1 = (_b = (_a = data.t1) != null ? _a : data["tier 1"]) != null ? _b : data["11 or lower"];
    this.t2 = (_d = (_c = data.t2) != null ? _c : data["tier 2"]) != null ? _d : data["12-16"];
    this.t3 = (_f = (_e = data.t3) != null ? _e : data["tier 3"]) != null ? _f : data["17+"];
    this.crit = (_h = (_g = data.critical) != null ? _g : data.crit) != null ? _h : data["nat 19-20"];
  }
  effectType() {
    return "PowerRollEffect";
  }
  asView(parent, plugin, ctx) {
    new PowerRollEffectView(plugin, this, ctx).build(parent);
  }
};
var MundaneEffect = class extends Effect {
  constructor(name, cost, effect) {
    super();
    this.name = name;
    this.cost = cost ? "" + cost : cost;
    this.effect = effect;
  }
  static parseKeyValue(data) {
    const key = Object.keys(data)[0];
    const effect = Object.values(data)[0];
    return new MundaneEffect(key, void 0, effect);
  }
  static parse(data) {
    return new MundaneEffect(data.name, data.cost, data.effect);
  }
  static nameless(effect) {
    return new MundaneEffect(void 0, void 0, effect);
  }
  effectType() {
    return "MundaneEffect";
  }
  asView(parent, plugin, ctx) {
    new MundaneEffectView(plugin, this, ctx).build(parent);
  }
};

// src/model/Ability.ts
var Ability = class {
  static parse(source) {
    let data;
    try {
      data = (0, import_obsidian17.parseYaml)(source);
    } catch (error) {
      throw new Error("Invalid YAML format: " + error.message);
    }
    return new Ability(data);
  }
  constructor(data) {
    this.indent = typeof data.indent === "string" ? parseInt(data.indent) : data.indent;
    this.name = data.name;
    this.cost = data.cost;
    this.flavor = data.flavor;
    if (data.keywords) {
      this.keywords = Array.isArray(data.keywords) ? data.keywords : [data.keywords];
    }
    this.type = data.type;
    this.distance = data.distance;
    this.target = data.target;
    this.trigger = data.trigger;
    this.effects = Effect.parseAll(data.effects);
  }
};

// src/model/StatblockData.ts
var StatblockData = class {
  constructor(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    this.name = data.name;
    this.level = data.level;
    this.roles = (_a = data.roles) != null ? _a : [];
    this.ancestry = (_b = data.ancestry) != null ? _b : [];
    this.ev = data.ev;
    this.stamina = data.stamina;
    this.immunities = (_c = data.immunities) != null ? _c : [];
    this.weaknesses = (_d = data.weaknesses) != null ? _d : [];
    this.speed = data.speed;
    this.size = data.size;
    this.stability = data.stability;
    this.freeStrike = (_e = data.free_strike) != null ? _e : data.freeStrike;
    this.characteristics = data.characteristics ? new Characteristics(data.characteristics) : new Characteristics({});
    this.traits = (_g = (_f = data.traits) == null ? void 0 : _f.map((t) => new Trait(t))) != null ? _g : [];
    this.abilities = (_i = (_h = data.abilities) == null ? void 0 : _h.map((a) => new Ability(a))) != null ? _i : [];
  }
};
var Characteristics = class {
  constructor(data) {
    this.might = data.might;
    this.agility = data.agility;
    this.reason = data.reason;
    this.intuition = data.intuition;
    this.presence = data.presence;
  }
};
var Trait = class {
  constructor(data) {
    var _a, _b, _c, _d, _e;
    this.name = (_b = (_a = data.name) == null ? void 0 : _a.trim()) != null ? _b : "";
    this.type = (_c = data.type) == null ? void 0 : _c.trim();
    this.effect = (_e = (_d = data.effect) == null ? void 0 : _d.trim()) != null ? _e : "";
  }
};
function parseStatblockData(source) {
  var _a, _b, _c, _d, _e;
  let data;
  try {
    data = (0, import_obsidian18.parseYaml)(source);
  } catch (error) {
    throw new Error("Invalid YAML format: " + error.message);
  }
  let statblockData = {};
  statblockData.name = data.name;
  statblockData.level = data.level;
  statblockData.roles = (_a = data.roles) != null ? _a : [];
  statblockData.ancestry = (_b = data.ancestry) != null ? _b : [];
  statblockData.ev = data.ev;
  statblockData.stamina = data.stamina;
  statblockData.immunities = (_c = data.immunities) != null ? _c : [];
  statblockData.weaknesses = (_d = data.weaknesses) != null ? _d : [];
  statblockData.speed = data.speed;
  statblockData.size = data.size;
  statblockData.stability = data.stability;
  statblockData.freeStrike = (_e = data.free_strike) != null ? _e : data.freeStrike;
  statblockData.characteristics = new Characteristics({
    might: parseCharacteristic(data.might),
    agility: parseCharacteristic(data.agility),
    reason: parseCharacteristic(data.reason),
    intuition: parseCharacteristic(data.intuition),
    presence: parseCharacteristic(data.presence)
  });
  if ("traits" in data) {
    statblockData.traits = data.traits.map((t) => new Trait(t));
  }
  if ("abilities" in data) {
    statblockData.abilities = data.abilities.map((a) => new Ability(a));
  }
  return new StatblockData(statblockData);
}
function parseCharacteristic(attrValue) {
  if (typeof attrValue === "string") {
    let value = parseInt(attrValue.replace("+", ""));
    if (!isNaN(value)) {
      return value;
    } else {
      console.warn(`Invalid characteristic value: ${attrValue}`);
      return void 0;
    }
  } else if (typeof attrValue === "number") {
    return attrValue;
  } else {
    return void 0;
  }
}

// src/drawSteelAdmonition/statblock/HeaderView.ts
var HeaderView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const headerContainer = parent.createEl("div", { cls: "ds-sb-header" });
    this.titleLine(headerContainer);
    this.infoLine(headerContainer);
  }
  titleLine(parent) {
    var _a, _b, _c;
    const firstLine = parent.createEl("div", { cls: "ds-sb-title-line" });
    const nameEl = firstLine.createEl("div", { cls: "ds-sb-header-left", text: (_a = this.data.name) != null ? _a : "Unnamed Creature" });
    const level = this.data.level !== void 0 ? `Level ${this.data.level}` : "Level N/A";
    const roles = (_c = (_b = this.data.roles) == null ? void 0 : _b.join(", ")) != null ? _c : "No Role";
    const levelRolesText = `${level} ${roles}`;
    const levelRolesEl = firstLine.createEl("div", { cls: "ds-sb-header-right", text: levelRolesText });
  }
  infoLine(parent) {
    var _a, _b;
    const secondLine = parent.createEl("div", { cls: "ds-sb-info-line" });
    const ancestryText = (_b = (_a = this.data.ancestry) == null ? void 0 : _a.join(", ")) != null ? _b : "Unknown Ancestry";
    const ancestryEl = secondLine.createEl("div", { cls: "ds-sb-header-left", text: ancestryText });
    const evText = this.data.ev !== void 0 ? `EV ${this.data.ev}` : "EV N/A";
    const evEl = secondLine.createEl("div", { cls: "ds-sb-header-right", text: evText });
  }
};

// src/drawSteelAdmonition/statblock/StatsView.ts
var StatsView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const statsContainer = parent.createEl("div", { cls: "ds-sb-stats" });
    const firstLine = statsContainer.createEl("div", { cls: "ds-sb-stats-line" });
    const leftEl2 = firstLine.createEl(
      "div",
      { cls: "ds-sb-stats-left", text: `Stamina ${(_a = this.data.stamina) != null ? _a : "N/A"}` }
    );
    const immuText = ((_b = this.data.immunities) == null ? void 0 : _b.length) > 0 ? `Immunity: ${(_c = this.data.immunities) == null ? void 0 : _c.join(", ")}` : "";
    const weakText = ((_d = this.data.weaknesses) == null ? void 0 : _d.length) > 0 ? `Weakness: ${(_e = this.data.weaknesses) == null ? void 0 : _e.join(", ")}` : "";
    const immuWeakText = `${immuText} ${weakText}`;
    const rightEl2 = firstLine.createEl("div", { cls: "ds-sb-stats-right", text: immuWeakText });
    const secondLine = statsContainer.createEl("div", { cls: "ds-sb-stats-line" });
    const leftEl1 = secondLine.createEl(
      "div",
      { cls: "ds-sb-stats-left", text: `Speed ${(_f = this.data.speed) != null ? _f : "N/A"}` }
    );
    const rightEl1 = secondLine.createEl(
      "div",
      { cls: "ds-sb-stats-right", text: `Size ${(_g = this.data.size) != null ? _g : "N/A"} / Stability ${(_h = this.data.stability) != null ? _h : "N/A"}` }
    );
    const thirdLine = statsContainer.createEl("div", { cls: "ds-sb-stats-line" });
    const leftEl = thirdLine.createEl(
      "div",
      { cls: "ds-sb-stats-left", text: "" }
    );
    const rightEl = thirdLine.createEl(
      "div",
      { cls: "ds-sb-stats-right", text: `Free Strike ${(_i = this.data.freeStrike) != null ? _i : "N/A"}` }
    );
    const fourthLine = statsContainer.createEl("div", { cls: "ds-sb-stats-line ds-sb-characteristics-line" });
    fourthLine.createEl("div", { cls: "ds-sb-characteristics-pair", text: `Might ${this.formatCharacteristic(this.data.characteristics.might)}` });
    fourthLine.createEl("div", { cls: "ds-sb-characteristics-pair", text: `Agility ${this.formatCharacteristic(this.data.characteristics.agility)}` });
    fourthLine.createEl("div", { cls: "ds-sb-characteristics-pair", text: `Reason ${this.formatCharacteristic(this.data.characteristics.reason)}` });
    fourthLine.createEl("div", { cls: "ds-sb-characteristics-pair", text: `Intuition ${this.formatCharacteristic(this.data.characteristics.intuition)}` });
    fourthLine.createEl("div", { cls: "ds-sb-characteristics-pair", text: `Presence ${this.formatCharacteristic(this.data.characteristics.presence)}` });
  }
  formatCharacteristic(value) {
    if (value === void 0 || isNaN(value)) {
      return "N/A";
    }
    return value >= 0 ? `+${value}` : `${value}`;
  }
};

// src/drawSteelAdmonition/ability/AbilityView.ts
var import_obsidian19 = require("obsidian");
var AbilityView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const container = parent.createEl("div", { cls: "ds-ability-container" });
    if (this.data.indent) {
      container.addClass("indent-" + this.data.indent);
    }
    const typeContainer = container.createEl("div", { cls: "pr-name-line" });
    if (this.data.name) {
      this.renderMD(this.ctx, this.data.name, typeContainer.createEl("span", { cls: "ability-name-value ds-multiline" }));
    }
    if (this.data.cost) {
      this.renderMD(this.ctx, " (" + String(this.data.cost).trim() + ")", typeContainer.createEl("span", { cls: "ability-cost-value" }));
    }
    if (this.data.flavor) {
      const flavorContainer = container.createEl("div", { cls: "ability-detail-line pr-flavor-line" });
      this.renderMD(this.ctx, this.data.flavor, flavorContainer.createEl("span", { cls: "ability-flavor-value ds-multiline" }));
    }
    if (this.data.keywords || this.data.type) {
      const row1 = container.createEl("div", { cls: "ability-detail-table-row" });
      const keywordCell = row1.createEl("div", { cls: "ability-detail-table-cell pr-keyword-cell" });
      if (this.data.keywords) {
        keywordCell.createEl("span", { cls: "ability-detail-key pr-keyword-key", text: "Keywords: " });
        const keywordsText = this.data.keywords.length > 0 ? this.data.keywords.join(", ") : "";
        this.renderMD(this.ctx, keywordsText, keywordCell.createEl("span", { cls: "pr-detail-value pr-keyword-value ds-multiline" }));
      }
      const typeCell = row1.createEl("div", { cls: "ability-detail-table-cell pr-type-cell" });
      if (this.data.type) {
        typeCell.createEl("span", { cls: "ability-detail-key pr-type-key", text: "Type: " });
        this.renderMD(this.ctx, this.data.type, typeCell.createEl("span", { cls: "pr-detail-value pr-type-value ds-multiline" }));
      }
    }
    if (this.data.distance || this.data.target) {
      const row2 = container.createEl("div", { cls: "ability-detail-table-row" });
      const distanceCell = row2.createEl("div", { cls: "ability-detail-table-cell pr-distance-cell" });
      if (this.data.distance) {
        distanceCell.createEl("span", { cls: "ability-detail-key pr-distance-key", text: "Distance: " });
        this.renderMD(this.ctx, this.data.distance, distanceCell.createEl("span", { cls: "pr-detail-value pr-distance-value ds-multiline" }));
      }
      const targetCell = row2.createEl("div", { cls: "ability-detail-table-cell pr-target-cell" });
      if (this.data.target) {
        targetCell.createEl("span", { cls: "ability-detail-key pr-target-key", text: "Target: " });
        this.renderMD(this.ctx, this.data.target, targetCell.createEl("span", { cls: "pr-detail-value pr-target-value ds-multiline" }));
      }
    }
    if (this.data.trigger) {
      const triggerContainer = container.createEl("div", { cls: "ability-detail-line pr-trigger-line" });
      triggerContainer.createEl("span", { cls: "ability-detail-key pr-trigger-key", text: "Trigger: " });
      this.renderMD(this.ctx, this.data.trigger, triggerContainer.createEl("span", { cls: "pr-detail-value pr-trigger-value ds-multiline" }));
    }
    const effectsContainer = container.createEl("div", { cls: "ds-effects-container" });
    if (this.data.effects) {
      for (let effect of this.data.effects) {
        effect.asView(effectsContainer, this.plugin, this.ctx);
      }
    }
  }
  // This will parse a string and render it as markdown
  renderMD(ctx, markdown, el) {
    el.addClass("ability-inline-p");
    import_obsidian19.MarkdownRenderer.render(this.plugin.app, markdown, el, ctx.sourcePath, this.plugin);
  }
};

// src/drawSteelAdmonition/statblock/AbilitiesView.ts
var AbilitiesView = class {
  constructor(plugin, abilities, ctx) {
    this.plugin = plugin;
    this.abilities = abilities;
    this.ctx = ctx;
  }
  build(container) {
    if (!this.abilities || this.abilities.length === 0) {
      return;
    }
    const abilitiesContainer = container.createEl("div", { cls: "ds-sb-abilities" });
    this.abilities.forEach((ability) => {
      new AbilityView(this.plugin, ability, this.ctx).build(abilitiesContainer);
    });
  }
};

// src/drawSteelAdmonition/statblock/TraitsView.ts
var TraitsView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(container) {
    if (!this.data.traits || this.data.traits.length === 0) {
      return;
    }
    const traitsContainer = container.createEl("div", { cls: "ds-sb-traits" });
    this.data.traits.forEach((trait) => {
      const traitEl = traitsContainer.createEl("div", { cls: "ds-sb-trait" });
      const titleText = trait.type ? `${trait.name} (${trait.type})` : trait.name;
      traitEl.createEl("div", { cls: "ds-sb-trait-title", text: titleText });
      traitEl.createEl("div", { cls: "ds-sb-trait-effect", text: trait.effect });
    });
  }
};

// src/drawSteelAdmonition/statblock/StatblockProcessor.ts
var StatblockProcessor = class {
  constructor(plugin) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.plugin = plugin;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-sb-container ds-container" });
    try {
      const data = parseStatblockData(source);
      this.buildUI(container, data, ctx);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the Statblock Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message ds-container" });
    }
  }
  buildUI(container, data, ctx) {
    new HeaderView(this.plugin, data, ctx).build(container);
    new StatsView(this.plugin, data, ctx).build(container);
    if (data.traits.length > 0) {
      HorizontalRuleProcessor.build(container);
      new TraitsView(this.plugin, data, ctx).build(container);
    }
    let abilities = [];
    let villainPowers = [];
    data.abilities.forEach((a) => {
      var _a;
      !((_a = a.type) == null ? void 0 : _a.startsWith("Villain Action")) ? abilities.push(a) : villainPowers.push(a);
    });
    if (abilities.length > 0) {
      HorizontalRuleProcessor.build(container);
      new AbilitiesView(this.plugin, abilities, ctx).build(container);
    }
    if (villainPowers.length > 0) {
      HorizontalRuleProcessor.build(container);
      new AbilitiesView(this.plugin, villainPowers, ctx).build(container);
    }
  }
};

// src/views/SettingsTab.ts
var import_obsidian21 = require("obsidian");

// src/utils/CompendiumDownloader.ts
var import_obsidian20 = require("obsidian");
var import_jszip = __toESM(require_jszip_min());
var CompendiumDownloader = class {
  constructor(app, githubOwner, githubRepo, githubToken) {
    this.app = app;
    this.githubOwner = githubOwner;
    this.githubRepo = githubRepo;
    this.githubToken = githubToken;
  }
  async downloadAndExtractRelease(releaseTag, destinationDirectory) {
    try {
      let releaseApiUrl = `https://api.github.com/repos/${this.githubOwner}/${this.githubRepo}/releases`;
      if (releaseTag) {
        releaseApiUrl += `/tags/${releaseTag}`;
      } else {
        releaseApiUrl += "/latest";
      }
      const headers = {
        Accept: "application/vnd.github.v3+json"
      };
      if (this.githubToken) {
        headers.Authorization = `token ${this.githubToken}`;
      }
      const releaseResponse = await (0, import_obsidian20.request)({
        url: releaseApiUrl,
        method: "GET",
        headers
      });
      const releaseData = JSON.parse(releaseResponse);
      const asset = releaseData.assets.find((a) => a.name === "repo.zip");
      if (!asset) {
        throw new Error('DSE Release asset "repo.zip" not found.');
      }
      const assetRequestParams = {
        url: asset.url,
        method: "GET",
        headers: {
          Accept: "application/octet-stream",
          ...this.githubToken && { Authorization: `token ${this.githubToken}` }
        },
        contentType: "application/octet-stream",
        // Set 'arraybuffer' as the response type
        responseType: "arraybuffer"
      };
      new import_obsidian20.Notice("Draw Steel Elements: Downloading compendium...");
      const assetResponse = await (0, import_obsidian20.requestUrl)(assetRequestParams);
      if (assetResponse.status !== 200) {
        console.error("DSE Compendium asset download failed:", assetResponse);
        throw new Error(`Failed to download DSE Compendium asset. HTTP status code: ${assetResponse.status}`);
      }
      const buffer = new Uint8Array(assetResponse.arrayBuffer);
      if (!buffer || buffer.byteLength === 0) {
        throw new Error("Downloaded asset is empty.");
      }
      const dir = this.app.vault.getAbstractFileByPath(destinationDirectory);
      if (dir) {
        await this.app.vault.delete(dir, true);
      }
      new import_obsidian20.Notice("Draw Steel Elements: Extracting compendium...");
      const zip = await import_jszip.default.loadAsync(buffer);
      await this.extractAndSaveZip(zip, destinationDirectory);
      new import_obsidian20.Notice("Draw Steel Elements: Compendium downloaded and extracted successfully.");
    } catch (error) {
      console.error("Error downloading DSE Compendium release:", error);
      new import_obsidian20.Notice(`Error: ${error.message}`);
    }
  }
  async extractAndSaveZip(zip, destinationDirectory) {
    const vault = this.app.vault;
    const files = Object.entries(zip.files);
    const batchSize = 20;
    for (let i = 0; i < files.length; i += batchSize) {
      const batch = files.slice(i, i + batchSize);
      await Promise.all(batch.map(async ([relativePath, zipEntry]) => {
        if (zipEntry.dir) {
          return;
        } else {
          const fileData = await zipEntry.async("uint8array");
          const filePath = `${destinationDirectory}/${relativePath}`;
          const pathParts = filePath.split("/").slice(0, -1);
          let currentPath = "";
          for (const part of pathParts) {
            currentPath = currentPath ? `${currentPath}/${part}` : part;
            if (!vault.getAbstractFileByPath(currentPath)) {
              try {
                await vault.createFolder(currentPath);
              } catch (error) {
                if (!error.message.includes("Folder already exists")) {
                  throw error;
                }
              }
            }
          }
          await vault.createBinary(filePath, fileData);
        }
      }));
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
  }
};

// src/views/SettingsTab.ts
var MyPluginSettingTab = class extends import_obsidian21.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Draw Steel Compendium Downloader" });
    containerEl.createEl("p", { text: "Important: The Compendium will download to a specific directory in your vault and delete any files in that directory" });
    new import_obsidian21.Setting(containerEl).setName("Release Tag (Optional)").setDesc(
      "Specific release tag to download. Leave empty to download the latest release."
    ).addText(
      (text) => text.setPlaceholder("v1.0.0").setValue(this.plugin.settings.compendiumReleaseTag).onChange(async (value) => {
        this.plugin.settings.compendiumReleaseTag = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian21.Setting(containerEl).setName("Destination Directory").setDesc("Directory within your vault to extract the Compendium contents to.  THIS DIRECTORY WILL BE WIPED CLEAN!").addText(
      (text) => text.setPlaceholder("ImportedContent").setValue(this.plugin.settings.compendiumDestinationDirectory).onChange(async (value) => {
        this.plugin.settings.compendiumDestinationDirectory = value;
        await this.plugin.saveSettings();
      })
    );
    const downloadButton = containerEl.createEl("button", { cls: "settings-action-button", text: "Download Compendium" });
    downloadButton.addEventListener("click", () => {
      return new CompendiumDownloader(this.app, this.plugin.githubOwner, this.plugin.githubRepo, void 0).downloadAndExtractRelease(this.plugin.settings.compendiumReleaseTag, this.plugin.settings.compendiumDestinationDirectory);
    });
  }
};

// src/model/Settings.ts
var DEFAULT_SETTINGS = {
  compendiumReleaseTag: "",
  // Leave empty to fetch the latest release
  compendiumDestinationDirectory: "DS Compendium"
  // Default directory in the vault
};

// src/drawSteelAdmonition/ability/AbilityProcessor.ts
var AbilityProcessor = class {
  constructor(plugin) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.plugin = plugin;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-ability-ele-container ds-container" });
    try {
      new AbilityView(this.plugin, Ability.parse(source), ctx).build(container);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the Ability Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message" });
    }
  }
};

// src/drawSteelAdmonition/StaminaBar/StaminaBarView.ts
var import_obsidian22 = require("obsidian");
var StaminaBarView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const container = parent.createEl("div", { cls: "ds-stamina-bar-container" });
    const staminaBarContainer = container.createEl("div", { cls: "stamina-bar-container" });
    if (this.data.height) {
      staminaBarContainer.style.height = this.data.height + "em";
    }
    const staminaBarOverlay = staminaBarContainer.createEl("div", { cls: "stamina-bar-overlay", text: "Dying" });
    const staminaBar = staminaBarContainer.createEl("div", { cls: "stamina-bar" });
    const staminaBarFillLeft = staminaBar.createEl("div", { cls: "stamina-bar-fill-left" });
    const staminaBarFillRight = staminaBar.createEl("div", { cls: "stamina-bar-fill-right" });
    this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
    container.addEventListener("click", () => {
      const modal = new StaminaEditModal(this.plugin.app, this.data, true, "", () => {
        this.updateStaminaBar(staminaBarFillLeft, staminaBarFillRight);
        CodeBlocks.updateStaminaBar(this.plugin.app, this.data, this.ctx);
      });
      modal.open();
    });
  }
  // This will parse a string and render it as markdown
  renderMD(ctx, markdown, el) {
    el.addClass("staminaBar-inline-p");
    import_obsidian22.MarkdownRenderer.render(this.plugin.app, markdown, el, ctx.sourcePath, this.plugin);
  }
  updateStaminaBar(staminaBarFillLeft, staminaBarFillRight) {
    const dyingLength = Math.ceil(-0.5 * this.data.max_stamina) * -1;
    const barLength = this.data.max_stamina + dyingLength;
    staminaBarFillLeft.style.width = `${(this.data.current_stamina + dyingLength) / barLength * 100}%`;
    staminaBarFillLeft.style.backgroundColor = "limegreen";
    staminaBarFillRight.style.width = `0%`;
    staminaBarFillRight.style.backgroundColor = "deepskyblue";
  }
};

// src/drawSteelAdmonition/StaminaBar/StaminaBarProcessor.ts
var StaminaBarProcessor = class {
  constructor(plugin) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.plugin = plugin;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-stamina-bar-ele-container" });
    try {
      new StaminaBarView(this.plugin, StaminaBar.parseYaml(source), ctx).build(container);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the StaminaBar Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message" });
    }
  }
};

// src/drawSteelAdmonition/Counter/CounterView.ts
var import_obsidian23 = require("obsidian");
var CounterView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const container = parent.createEl("div", { cls: "ds-counter-container" });
    const displayContainer = container.createEl("div", { cls: "ds-counter-display-container" });
    const valueDisplay = displayContainer.createEl("div", {
      cls: "ds-counter-value",
      text: this.data.current_value.toString()
    });
    valueDisplay.style.fontSize = `${this.data.value_height}em`;
    valueDisplay.addEventListener("click", () => {
      this.makeValueEditable(valueDisplay, incrementButton, decrementButton);
    });
    const nameDisplay = displayContainer.createEl("div", {
      cls: "ds-counter-name",
      text: this.data.name
    });
    nameDisplay.style.fontSize = `${this.data.name_height}em`;
    const controlsContainer = container.createEl("div", { cls: "ds-counter-controls" });
    const incrementButton = controlsContainer.createEl("button", { cls: "ds-counter-button" });
    (0, import_obsidian23.setIcon)(incrementButton, "chevron-up");
    incrementButton.addEventListener("click", () => {
      this.incrementValue();
      valueDisplay.textContent = this.data.current_value.toString();
      this.updateButtons(incrementButton, decrementButton);
      CodeBlocks.updateCounter(this.plugin.app, this.data, this.ctx);
    });
    const decrementButton = controlsContainer.createEl("button", { cls: "ds-counter-button" });
    (0, import_obsidian23.setIcon)(decrementButton, "chevron-down");
    decrementButton.addEventListener("click", () => {
      this.decrementValue();
      valueDisplay.textContent = this.data.current_value.toString();
      this.updateButtons(incrementButton, decrementButton);
      CodeBlocks.updateCounter(this.plugin.app, this.data, this.ctx);
    });
    this.updateButtons(incrementButton, decrementButton);
    container.addClass("ds-counter-flex");
  }
  incrementValue() {
    const { current_value, max_value } = this.data;
    if (max_value !== void 0 && current_value >= max_value) {
      return;
    }
    this.data.current_value += 1;
  }
  decrementValue() {
    const { current_value, min_value } = this.data;
    if (current_value <= min_value) {
      return;
    }
    this.data.current_value -= 1;
  }
  updateButtons(incrementButton, decrementButton) {
    const { current_value, max_value, min_value } = this.data;
    if (max_value !== void 0 && current_value >= max_value) {
      incrementButton.setAttribute("disabled", "true");
    } else {
      incrementButton.removeAttribute("disabled");
    }
    if (current_value <= min_value) {
      decrementButton.setAttribute("disabled", "true");
    } else {
      decrementButton.removeAttribute("disabled");
    }
  }
  makeValueEditable(valueDisplay, incrementButton, decrementButton) {
    const inputField = createEl("input", {
      type: "number",
      value: this.data.current_value.toString(),
      cls: "ds-counter-input"
    });
    inputField.style.fontSize = `${this.data.value_height}em`;
    inputField.style.height = `1em`;
    valueDisplay.replaceWith(inputField);
    inputField.focus();
    inputField.select();
    incrementButton.setAttribute("disabled", "true");
    decrementButton.setAttribute("disabled", "true");
    const finishEditing = () => {
      let newValue = parseInt(inputField.value);
      if (isNaN(newValue)) {
        newValue = this.data.current_value;
      } else {
        if (this.data.max_value !== void 0) {
          newValue = Math.min(newValue, this.data.max_value);
        }
        newValue = Math.max(newValue, this.data.min_value);
      }
      this.data.current_value = newValue;
      const newValueDisplay = createEl("div", {
        cls: "ds-counter-value",
        text: newValue.toString()
      });
      newValueDisplay.style.fontSize = `${this.data.value_height}em`;
      newValueDisplay.addEventListener("click", () => {
        this.makeValueEditable(newValueDisplay, incrementButton, decrementButton);
      });
      inputField.replaceWith(newValueDisplay);
      this.updateButtons(incrementButton, decrementButton);
      CodeBlocks.updateCounter(this.plugin.app, this.data, this.ctx);
    };
    inputField.addEventListener("blur", finishEditing);
    inputField.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        finishEditing();
      } else if (e.key === "Escape") {
        inputField.value = this.data.current_value.toString();
        finishEditing();
      }
    });
  }
};

// src/model/Counter.ts
var import_obsidian24 = require("obsidian");
var Counter = class {
  static parseYaml(source) {
    let data;
    try {
      data = (0, import_obsidian24.parseYaml)(source);
    } catch (error) {
      throw new Error("Invalid YAML format: " + error.message);
    }
    return Counter.parse(data);
  }
  static parse(data) {
    return new Counter(
      data.max_value,
      data.current_value ? data.current_value : 0,
      data.min_value ? data.min_value : 0,
      data.name,
      data.value_height ? data.value_height : 3,
      data.name_height ? data.name_height : 1
    );
  }
  constructor(max_value, current_value, min_value, name, value_height, name_height) {
    this.max_value = max_value;
    this.current_value = current_value;
    this.min_value = min_value;
    this.name = name;
    this.value_height = value_height;
    this.name_height = name_height;
  }
};

// src/drawSteelAdmonition/Counter/CounterProcessor.ts
var CounterProcessor = class {
  constructor(plugin) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.plugin = plugin;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-counter-ele-container" });
    try {
      new CounterView(this.plugin, Counter.parseYaml(source), ctx).build(container);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the Counter Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message" });
    }
  }
};

// src/drawSteelAdmonition/Characteristics/CharacteristicsView.ts
var CharacteristicsView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const container = parent.createEl("div", { cls: "ds-characteristics-container" });
    const rowContainer = container.createEl("div", { cls: "ds-characteristics-row" });
    const characteristics = [
      { name: "Might", value: this.data.might },
      { name: "Agility", value: this.data.agility },
      { name: "Reason", value: this.data.reason },
      { name: "Intuition", value: this.data.intuition },
      { name: "Presence", value: this.data.presence }
    ];
    characteristics.forEach((char) => {
      var _a, _b;
      const cell = rowContainer.createEl("div", { cls: "ds-characteristics-cell" });
      const valueDisplay = cell.createEl("div", {
        cls: "ds-characteristics-value",
        text: (_a = char.value) != null ? _a : ""
      });
      valueDisplay.style.fontSize = `${this.data.value_height}em`;
      const nameDisplay = cell.createEl("div", {
        cls: "ds-characteristics-name",
        text: (_b = char.name) != null ? _b : ""
      });
      nameDisplay.style.fontSize = `${this.data.name_height}em`;
    });
  }
};

// src/model/Characteristics.ts
var import_obsidian25 = require("obsidian");
var Characteristics2 = class {
  static parseYaml(source) {
    let data;
    try {
      data = (0, import_obsidian25.parseYaml)(source);
    } catch (error) {
      throw new Error("Invalid YAML format: " + error.message);
    }
    return Characteristics2.parse(data);
  }
  static parse(data) {
    return new Characteristics2(
      data.might ? data.might : 0,
      data.agility ? data.agility : 0,
      data.reason ? data.reason : 0,
      data.intuition ? data.intuition : 0,
      data.presence ? data.presence : 0,
      data.value_height ? data.value_height : 3,
      data.name_height ? data.name_height : 1
    );
  }
  constructor(might, agility, reason, intuition, presence, value_height, name_height) {
    this.might = might;
    this.agility = agility;
    this.reason = reason;
    this.intuition = intuition;
    this.presence = presence;
    this.value_height = value_height;
    this.name_height = name_height;
  }
};

// src/drawSteelAdmonition/Characteristics/CharacteristicsProcessor.ts
var CharacteristicsProcessor = class {
  constructor(plugin) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.plugin = plugin;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-characteristics-ele-container" });
    try {
      new CharacteristicsView(this.plugin, Characteristics2.parseYaml(source), ctx).build(container);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the Characteristics Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message" });
    }
  }
};

// src/utils/SkillsData.ts
var SKILL_DATA = {
  "crafting": [
    { name: "alchemy", use: "Make bombs and potions" },
    { name: "architecture", use: "Create buildings and vehicles" },
    { name: "blacksmithing", use: "Forge metal armor and weapons" },
    { name: "fletching", use: "Make ranged weapons and ammunition" },
    { name: "forgery", use: "Create false badges, documents, and other items" },
    { name: "jewelry", use: "Create bracelets, crowns, rings, and other jewelry" },
    { name: "mechanics", use: "Build machines and clockwork items" },
    { name: "tailoring", use: "Craft cloth and leather clothing" }
  ],
  "exploration": [
    { name: "climb", use: "Move up vertical surfaces" },
    { name: "drive", use: "Control vehicles" },
    { name: "endurance", use: "Remain engaged in strenuous activity over a long period" },
    { name: "gymnastics", use: "Move across unsteady or narrow surfaces, and tumble" },
    { name: "heal", use: "Use mundane first aid" },
    { name: "jump", use: "Leap vertical and horizontal distances" },
    { name: "lift", use: "Pick up, carry, and throw heavy objects" },
    { name: "navigate", use: "Read a map and travel without becoming lost" },
    { name: "ride", use: "Ride and control a mount who isn't sapient, such as a horse" },
    { name: "swim", use: "Move through deep liquid" }
  ],
  "interpersonal": [
    { name: "brag", use: "Impress others with stories of your deeds" },
    { name: "empathize", use: "Relate to someone on a personal level" },
    { name: "flirt", use: "Attract romantic attention from someone" },
    { name: "gamble", use: "Make bets with others" },
    { name: "handle animals", use: "Interact with animal wildlife that isn't sapient" },
    { name: "interrogate", use: "Obtain information from a creature withholding it" },
    { name: "intimidate", use: "Awe or scare a creature" },
    { name: "lead", use: "Inspire people to action" },
    { name: "lie", use: "Convince someone that a falsehood is true" },
    { name: "music", use: "Perform music vocally or with an instrument" },
    { name: "perform", use: "Engage in dance, oratory, acting, or other physical performance" },
    { name: "persuade", use: "Convince someone to agree with you through use of your charms and grace" },
    { name: "read person", use: "Read the emotions and body language of other creatures" }
  ],
  "intrigue": [
    { name: "alertness", use: "Intuitively sense the details of your surroundings" },
    { name: "conceal object", use: "Hide an object on your person or in your environment" },
    { name: "disguise", use: "Change your appearance to look like a different person" },
    { name: "eavesdrop", use: "Actively listen to something that is hard to hear" },
    { name: "escape artist", use: "Escape from bonds such as rope or manacles" },
    { name: "hide", use: "Conceal yourself from others' observation" },
    { name: "pick lock", use: "Open a lock without using the key" },
    { name: "pick pocket", use: "Steal an item that another person wears or carries without them noticing" },
    { name: "sabotage", use: "Disable a mechanical device such as a trap" },
    { name: "search", use: "Actively search an environment for important details and items" },
    { name: "sneak", use: "Move silently" },
    { name: "track", use: "Follow a trail that another creature has left behind" }
  ],
  "lore": [
    { name: "culture", use: "Knowing about a culture's customs, folktales, and taboos" },
    { name: "criminal underworld", use: "Knowing about criminal organizations, their crimes, relationships, and leaders" },
    { name: "history", use: "Knowing about significant past events" },
    { name: "magic", use: "Knowing about magical places, spells, rituals, items, and phenomena" },
    { name: "monsters", use: "Knowing monster ecology, strengths, and weaknesses" },
    { name: "nature", use: "Knowing about natural flora, fauna, and weather" },
    { name: "psionics", use: "Knowing about psionic places, spells, rituals, items, and phenomena" },
    { name: "religion", use: "Knowing about religious mythology, practices, and rituals" },
    { name: "rumors", use: "Knowing gossip, legends, and uncertain truths" },
    { name: "society", use: "Knowing noble etiquette and the leadership and power dynamics of noble families" },
    { name: "timescape", use: "Knowing about the various planets of the timescape" }
  ]
};

// src/drawSteelAdmonition/Skills/SkillsView.ts
var SkillsView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const container = parent.createEl("div", { cls: "ds-skills-container" });
    for (const groupName in SKILL_DATA) {
      const groupSkills = SKILL_DATA[groupName];
      const groupContainer = container.createEl("div", { cls: "ds-skill-group" });
      const groupTitle = groupContainer.createEl("h3", { text: groupName, cls: "ds-skill-group-title" });
      const skillsList = groupContainer.createEl("ul", { cls: "ds-skill-list" });
      groupSkills.forEach((skillInfo) => {
        const hasSkill = this.hasSkill(skillInfo.name);
        const skillItem = skillsList.createEl("li", { cls: "ds-skill-item" });
        const indicator = skillItem.createEl("span", { cls: "ds-skill-indicator" });
        indicator.addClass(hasSkill ? "enabled" : "disabled");
        const skillName = skillItem.createEl("span", { cls: "ds-skill-name", text: skillInfo.name });
        skillName.setAttribute("title", skillInfo.use);
      });
      const customSkillsInGroup = this.data.custom_skills.filter(
        (cs) => cs.skill_group && cs.skill_group.toLowerCase() === groupName.toLowerCase()
      );
      customSkillsInGroup.forEach((customSkill) => {
        const skillItem = skillsList.createEl("li", { cls: "ds-skill-item" });
        const indicator = skillItem.createEl("span", { cls: "ds-skill-indicator" });
        indicator.addClass(customSkill.has_skill ? "enabled" : "disabled");
        const skillName = skillItem.createEl("span", { cls: "ds-skill-name", text: customSkill.name });
        skillName.setAttribute("title", customSkill.description || "");
      });
    }
    const customSkillsWithoutGroup = this.data.custom_skills.filter(
      (cs) => !cs.skill_group || !(cs.skill_group.toLowerCase() in SKILL_DATA)
    );
    if (customSkillsWithoutGroup.length > 0) {
      const customGroupContainer = container.createEl("div", { cls: "ds-skill-group" });
      const customGroupTitle = customGroupContainer.createEl("h3", {
        text: "Custom Skills",
        cls: "ds-skill-group-title"
      });
      const customSkillsList = customGroupContainer.createEl("ul", { cls: "ds-skill-list" });
      customSkillsWithoutGroup.forEach((customSkill) => {
        const skillItem = customSkillsList.createEl("li", { cls: "ds-skill-item" });
        const indicator = skillItem.createEl("span", { cls: "ds-skill-indicator" });
        indicator.addClass(customSkill.has_skill ? "enabled" : "disabled");
        const skillName = skillItem.createEl("span", { cls: "ds-skill-name", text: customSkill.name });
      });
    }
  }
  hasSkill(skillName) {
    return this.data.skills.some((skill) => skill.toLowerCase() === skillName.toLowerCase());
  }
};

// src/model/Skills.ts
var import_obsidian26 = require("obsidian");
var Skills = class {
  static parseYaml(source) {
    let data;
    try {
      data = (0, import_obsidian26.parseYaml)(source);
    } catch (error) {
      throw new Error("Invalid YAML format: " + error.message);
    }
    return Skills.parse(data);
  }
  static parse(data) {
    const skills = data.skills ? data.skills : [];
    let custom_skills = [];
    if (data.custom_skills && Array.isArray(data.custom_skills)) {
      data.custom_skills.forEach((cs) => custom_skills.push(CustomSkill.parse(cs)));
    }
    return new Skills(skills, custom_skills);
  }
  constructor(skills, custom_skills) {
    this.skills = skills;
    this.custom_skills = custom_skills;
  }
};
var CustomSkill = class {
  static parse(data) {
    var _a;
    return new CustomSkill(data.name, (_a = data.has_skill) != null ? _a : true, data.skill_group, data.description);
  }
  constructor(name, has_skill, skill_group, description) {
    this.name = name;
    this.has_skill = has_skill;
    this.skill_group = skill_group;
    this.description = description;
  }
};

// src/drawSteelAdmonition/Skills/SkillsProcessor.ts
var SkillsProcessor = class {
  constructor(plugin) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.plugin = plugin;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-skills-ele-container" });
    try {
      new SkillsView(this.plugin, Skills.parseYaml(source), ctx).build(container);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the Skills Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message" });
    }
  }
};

// src/drawSteelAdmonition/ValuesRow/ValuesRowView.ts
var ValuesRowView = class {
  constructor(plugin, data, ctx) {
    this.plugin = plugin;
    this.data = data;
    this.ctx = ctx;
  }
  build(parent) {
    const container = parent.createEl("div", { cls: "ds-values-row-container" });
    const rowContainer = container.createEl("div", { cls: "ds-values-row-row" });
    this.data.values.forEach((pair) => {
      var _a, _b;
      const cell = rowContainer.createEl("div", { cls: "ds-values-row-cell" });
      const valueDisplay = cell.createEl("div", {
        cls: "ds-values-row-value",
        text: (_a = pair.value) != null ? _a : ""
      });
      valueDisplay.style.fontSize = `${this.data.value_height}em`;
      const nameDisplay = cell.createEl("div", {
        cls: "ds-values-row-name",
        text: (_b = pair.name) != null ? _b : ""
      });
      nameDisplay.style.fontSize = `${this.data.name_height}em`;
    });
  }
};

// src/model/KeyValuePairs.ts
var import_obsidian27 = require("obsidian");
var KeyValuePairs = class {
  static parseYaml(source) {
    let data;
    try {
      data = (0, import_obsidian27.parseYaml)(source);
    } catch (error) {
      throw new Error("Invalid YAML format: " + error.message);
    }
    return KeyValuePairs.parse(data);
  }
  static parse(data) {
    return new KeyValuePairs(
      KVPair.parseAll(data.values),
      data.value_height ? data.value_height : 3,
      data.name_height ? data.name_height : 1
    );
  }
  constructor(values, value_height, name_height) {
    this.values = values;
    this.value_height = value_height;
    this.name_height = name_height;
  }
};
var KVPair = class {
  static parseAll(values) {
    if (!values) {
      return [];
    }
    if (!Array.isArray(values)) {
      throw new Error("Expected effects to be an array");
    }
    let effects = [];
    for (let entry of values) {
      if (entry.name && entry.effect) {
        effects.push(KVPair.parse(entry));
      } else if (typeof entry === "string" || typeof entry === "number") {
        effects.push(KVPair.nameless(entry));
      } else {
        effects.push(KVPair.parseKeyValue(entry));
      }
    }
    return effects;
  }
  static parseKeyValue(data) {
    const key = Object.keys(data)[0];
    const value = Object.values(data)[0];
    return new KVPair(key, value);
  }
  static parse(data) {
    return new KVPair(data.name, data.effect);
  }
  static nameless(effect) {
    return new KVPair(void 0, effect == null ? void 0 : effect.toString());
  }
  constructor(name, value) {
    this.name = name;
    this.value = value;
  }
};

// src/drawSteelAdmonition/ValuesRow/ValuesRowProcessor.ts
var ValuesRowProcessor = class {
  constructor(plugin) {
    this.handler = (source, el, ctx) => this.postProcess(source, el, ctx);
    this.plugin = plugin;
  }
  postProcess(source, el, ctx) {
    const container = el.createEl("div", { cls: "ds-values-row-ele-container" });
    try {
      new ValuesRowView(this.plugin, KeyValuePairs.parseYaml(source), ctx).build(container);
    } catch (error) {
      let userMessage = "The Draw Steel Elements plugin loaded the ValuesRow Element properly, but failed to process the input config.  Please correct the following error:\n\n";
      userMessage += error.message;
      container.createEl("div", { text: userMessage, cls: "error-message" });
    }
  }
};

// main.ts
var DrawSteelAdmonitionPlugin = class extends import_obsidian28.Plugin {
  constructor() {
    super(...arguments);
    this.githubOwner = "steelCompendium";
    this.githubRepo = "data-md-dse";
  }
  async onload() {
    console.log("Loading Draw Steel Elements Plugin.");
    await this.loadSettings();
    this.addSettingTab(new MyPluginSettingTab(this.app, this));
    this.registerElements();
    this.addCommand({
      id: "download-data-md-dse",
      name: "Download Compendium",
      callback: () => this.downloadAndExtractRelease()
    });
  }
  onunload() {
  }
  registerElements() {
    const abilityProcessor = new AbilityProcessor(this);
    this.registerMarkdownCodeBlockProcessor("ds-ab", abilityProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-ability", abilityProcessor.handler);
    const hrProcessor = new HorizontalRuleProcessor();
    this.registerMarkdownCodeBlockProcessor("ds-hr", hrProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-horizontal-rule", hrProcessor.handler);
    const initProcessor = new InitiativeProcessor(this.app);
    this.registerMarkdownCodeBlockProcessor("ds-it", initProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-init", initProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-initiative", initProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-initiative-tracker", initProcessor.handler);
    let ntProcessor = new NegotiationTrackerProcessor(this.app);
    this.registerMarkdownCodeBlockProcessor("ds-nt", ntProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-negotiation-tracker", ntProcessor.handler);
    let sbProcessor = new StatblockProcessor(this);
    this.registerMarkdownCodeBlockProcessor("ds-sb", sbProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-statblock", sbProcessor.handler);
    let stamProcessor = new StaminaBarProcessor(this);
    this.registerMarkdownCodeBlockProcessor("ds-stam", stamProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-stamina", stamProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-stamina-bar", stamProcessor.handler);
    let counterProcessor = new CounterProcessor(this);
    this.registerMarkdownCodeBlockProcessor("ds-ct", counterProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-counter", counterProcessor.handler);
    let charProcessor = new CharacteristicsProcessor(this);
    this.registerMarkdownCodeBlockProcessor("ds-char", charProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-characteristics", charProcessor.handler);
    let skillProcessor = new SkillsProcessor(this);
    this.registerMarkdownCodeBlockProcessor("ds-skills", skillProcessor.handler);
    let valRowProcessor = new ValuesRowProcessor(this);
    this.registerMarkdownCodeBlockProcessor("ds-vr", valRowProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-value-row", valRowProcessor.handler);
    this.registerMarkdownCodeBlockProcessor("ds-values-row", valRowProcessor.handler);
  }
  async downloadAndExtractRelease() {
    return new CompendiumDownloader(this.app, this.githubOwner, this.githubRepo, void 0).downloadAndExtractRelease(this.settings.compendiumReleaseTag, this.settings.compendiumDestinationDirectory);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/


/* nosourcemap */